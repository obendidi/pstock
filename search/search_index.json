{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pstock Disclaimer You should refer to Yahoo!'s terms of use ( here , here , and here ) for details on your rights to use the actual data downloaded. Remember - the project is intended for personal use only. Pstock is an open source tool/project that is not affiliated in any way to yahoo-finance. Nothing in this project should be considered investment advice. Documentation : https://obendidi.github.io/pstock Source Code : https://github.com/obendidi/pstock Pstock is yet another python unoficial API for getting yahoo-finance data. The key features are: Async first Data validation using pydantic Fully typed, with great editor support Easily extensible: Parse the yahoo-finance quote dict and extract any type of info you want. Follows the Sans-IO design pattern: Use your favourite http library (sync/async) and let pstock parse your response to get Assets or Bars Requirements Python 3.8+ (support for 3.6/3.7 may be added later, contributions are welcome) Pstock depends mainly on: pydantic : For data validation pandas : For structuring data in nice dataframes httpx : For the main async IO interface Installation $ pip install pstock-python ---> 100% Quickstart Download an asset: import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset ) # symbol='TSLA' name='Tesla, Inc.' asset_type='EQUITY' currency='USD' latest_price=920.0 sector='Consumer Cyclical' industry='Auto Manufacturers' Download a list of assets: import asyncio from pstock import Asset assets = asyncio . run ( Assets . get ([ \"TSLA\" , \"AAPL\" , \"GME\" ])) print ( assets ) # __root__=[Asset(symbol='TSLA', name='Tesla, Inc.', asset_type='EQUITY', currency='USD', latest_price=918.97, sector='Consumer Cyclical', industry='Auto Manufacturers'), Asset(symbol='AAPL', name='Apple Inc.', asset_type='EQUITY', currency='USD', latest_price=172.345, sector='Technology', industry='Consumer Electronics'), Asset(symbol='GME', name='GameStop Corp.', asset_type='EQUITY', currency='USD', latest_price=125.0, sector='Consumer Cyclical', industry='Specialty Retail')] print ( assets [ 0 ]) # Asset(symbol='TSLA', name='Tesla, Inc.', asset_type='EQUITY', currency='USD', latest_price=918.97, sector='Consumer Cyclical', industry='Auto Manufacturers') print ( assets . df ) name asset_type currency ... earnings trends income_statement symbol ... AAPL Apple Inc . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 0.99 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 13, ' buy ':... [{' date ': 2021-09-25, ' ebit ': 108949000000.0, ... GME GameStop Corp . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 1.35 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 2, ' buy ': ... [{' date ': 2021-01-30, ' ebit ': -249300000.0, ' t ... TSLA Tesla , Inc . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 0.79 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 4, ' buy ': ... [{' date ': 2021-12-31, ' ebit ': 6523000000.0, ' t ... Download historical bars: import asyncio from pstock import Bars bars = asyncio . run ( Bars . get ( \"TSLA\" )) print ( bars ) # __root__=[Bar(date=datetime.datetime(2010, 7, 1, 4, 0, tzinfo=datetime.timezone.utc), open=5.0, high=5.184000015258789, low=2.996000051498413, close=3.98799991607666, adj_close=3.98799991607666, volume=322879000.0, interval=Duration(months=1)), Bar(date=datetime.datetime(2010, 8, 1, 4, 0, tzinfo=datetime.timezone.utc), open=4.099999904632568, high=4.435999870300293, low=3.4779999256134033, close=3.8959999084472656, adj_close=3.8959999084472656, volume=75191000.0, interval=Duration(months=1)), Bar(date=datetime.datetime(2010, 9, 1, 4, 0, tzinfo=datetime.timezone.utc), open=3.9240000247955322, high=4.631999969482422, low=3.9000000953674316, close=4.081999778747559, adj_close=4.081999778747559, volume=90229500.0, interval=Duration(months=1)), Bar(date=datetime.datetime(2010, 10, 1, 4, 0, tzinfo=datetime.timezone.utc), open=4.138000011444092, high=4.374000072479248, low=4.0, close=4.368000030517578, adj_close=4.368000030517578, volume=32739000.0, interval=Duration(months=1)), ....] print ( bars . df ) open high low close adj_close volume interval date 2010 - 07 - 01 5.000000 5.184000 2.996000 3.988000 3.988000 322879000.0 30 days 2010 - 08 - 01 4.100000 4.436000 3.478000 3.896000 3.896000 75191000.0 30 days 2010 - 09 - 01 3.924000 4.632000 3.900000 4.082000 4.082000 90229500.0 30 days 2010 - 10 - 01 4.138000 4.374000 4.000000 4.368000 4.368000 32739000.0 30 days 2010 - 11 - 01 4.388000 7.200000 4.210000 7.066000 7.066000 141575500.0 30 days ... ... ... ... ... ... ... ... 2021 - 11 - 01 1145.000000 1243.489990 978.599976 1144.760010 1144.760010 648671800.0 30 days 2021 - 12 - 01 1160.699951 1172.839966 886.119995 1056.780029 1056.780029 509945100.0 30 days 2022 - 01 - 01 1147.750000 1208.000000 792.010010 936.719971 936.719971 638471400.0 30 days 2022 - 02 - 01 935.210022 947.770020 850.700012 875.760010 875.760010 223112600.0 30 days 2022 - 02 - 15 900.000000 923.000000 893.377380 922.429993 922.429993 19085243.0 30 days [ 141 rows x 7 columns ] Download stock news: import asyncio from pstock import News news = asyncio . run ( News . get ( \"TSLA\" )) print ( news . df ) title url summary date 2022 - 02 - 15 12 : 11 : 46 + 00 : 00 Retail investor : 'I' m being careful just in ca ... https : // finance . yahoo . com / news / retail - investor ... Some retail investors are being more cautious ... 2022 - 02 - 15 12 : 23 : 00 + 00 : 00 Tesla \u2019 s Elon Musk Gave Away $ 5.7 Billion . But ... https : // finance . yahoo . com / m / d342cd56 - d5bb - 3957. .. Tesla CEO Elon Musk gave away more than 5 mill ... 2022 - 02 - 15 13 : 07 : 02 + 00 : 00 Company News for Feb 15 , 2022 https : // finance . yahoo . com / news / company - news - fe ... Companies In The News Are : IFS , OLK , THS , TSLA . .... 2022 - 02 - 15 19 : 23 : 43 + 00 : 00 Australia 's Syrah Resources to expand Louisian... https://finance.yahoo.com/news/australias-syra... Australian industrial materials firm Syrah Res... 2022 - 02 - 15 20 : 31 : 30 + 00 : 00 Biggest Companies in the World by Market Cap https : // finance . yahoo . com / m / 8 aead0a5 - ef35 - 3 d90 ... The world 's biggest companies by market cap op... Contributors Feel free to contribute !","title":"Introduction"},{"location":"#pstock","text":"","title":"Pstock"},{"location":"#disclaimer","text":"You should refer to Yahoo!'s terms of use ( here , here , and here ) for details on your rights to use the actual data downloaded. Remember - the project is intended for personal use only. Pstock is an open source tool/project that is not affiliated in any way to yahoo-finance. Nothing in this project should be considered investment advice. Documentation : https://obendidi.github.io/pstock Source Code : https://github.com/obendidi/pstock Pstock is yet another python unoficial API for getting yahoo-finance data. The key features are: Async first Data validation using pydantic Fully typed, with great editor support Easily extensible: Parse the yahoo-finance quote dict and extract any type of info you want. Follows the Sans-IO design pattern: Use your favourite http library (sync/async) and let pstock parse your response to get Assets or Bars","title":"Disclaimer"},{"location":"#requirements","text":"Python 3.8+ (support for 3.6/3.7 may be added later, contributions are welcome) Pstock depends mainly on: pydantic : For data validation pandas : For structuring data in nice dataframes httpx : For the main async IO interface","title":"Requirements"},{"location":"#installation","text":"$ pip install pstock-python ---> 100%","title":"Installation"},{"location":"#quickstart","text":"Download an asset: import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset ) # symbol='TSLA' name='Tesla, Inc.' asset_type='EQUITY' currency='USD' latest_price=920.0 sector='Consumer Cyclical' industry='Auto Manufacturers' Download a list of assets: import asyncio from pstock import Asset assets = asyncio . run ( Assets . get ([ \"TSLA\" , \"AAPL\" , \"GME\" ])) print ( assets ) # __root__=[Asset(symbol='TSLA', name='Tesla, Inc.', asset_type='EQUITY', currency='USD', latest_price=918.97, sector='Consumer Cyclical', industry='Auto Manufacturers'), Asset(symbol='AAPL', name='Apple Inc.', asset_type='EQUITY', currency='USD', latest_price=172.345, sector='Technology', industry='Consumer Electronics'), Asset(symbol='GME', name='GameStop Corp.', asset_type='EQUITY', currency='USD', latest_price=125.0, sector='Consumer Cyclical', industry='Specialty Retail')] print ( assets [ 0 ]) # Asset(symbol='TSLA', name='Tesla, Inc.', asset_type='EQUITY', currency='USD', latest_price=918.97, sector='Consumer Cyclical', industry='Auto Manufacturers') print ( assets . df ) name asset_type currency ... earnings trends income_statement symbol ... AAPL Apple Inc . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 0.99 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 13, ' buy ':... [{' date ': 2021-09-25, ' ebit ': 108949000000.0, ... GME GameStop Corp . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 1.35 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 2, ' buy ': ... [{' date ': 2021-01-30, ' ebit ': -249300000.0, ' t ... TSLA Tesla , Inc . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 0.79 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 4, ' buy ': ... [{' date ': 2021-12-31, ' ebit ': 6523000000.0, ' t ... Download historical bars: import asyncio from pstock import Bars bars = asyncio . run ( Bars . get ( \"TSLA\" )) print ( bars ) # __root__=[Bar(date=datetime.datetime(2010, 7, 1, 4, 0, tzinfo=datetime.timezone.utc), open=5.0, high=5.184000015258789, low=2.996000051498413, close=3.98799991607666, adj_close=3.98799991607666, volume=322879000.0, interval=Duration(months=1)), Bar(date=datetime.datetime(2010, 8, 1, 4, 0, tzinfo=datetime.timezone.utc), open=4.099999904632568, high=4.435999870300293, low=3.4779999256134033, close=3.8959999084472656, adj_close=3.8959999084472656, volume=75191000.0, interval=Duration(months=1)), Bar(date=datetime.datetime(2010, 9, 1, 4, 0, tzinfo=datetime.timezone.utc), open=3.9240000247955322, high=4.631999969482422, low=3.9000000953674316, close=4.081999778747559, adj_close=4.081999778747559, volume=90229500.0, interval=Duration(months=1)), Bar(date=datetime.datetime(2010, 10, 1, 4, 0, tzinfo=datetime.timezone.utc), open=4.138000011444092, high=4.374000072479248, low=4.0, close=4.368000030517578, adj_close=4.368000030517578, volume=32739000.0, interval=Duration(months=1)), ....] print ( bars . df ) open high low close adj_close volume interval date 2010 - 07 - 01 5.000000 5.184000 2.996000 3.988000 3.988000 322879000.0 30 days 2010 - 08 - 01 4.100000 4.436000 3.478000 3.896000 3.896000 75191000.0 30 days 2010 - 09 - 01 3.924000 4.632000 3.900000 4.082000 4.082000 90229500.0 30 days 2010 - 10 - 01 4.138000 4.374000 4.000000 4.368000 4.368000 32739000.0 30 days 2010 - 11 - 01 4.388000 7.200000 4.210000 7.066000 7.066000 141575500.0 30 days ... ... ... ... ... ... ... ... 2021 - 11 - 01 1145.000000 1243.489990 978.599976 1144.760010 1144.760010 648671800.0 30 days 2021 - 12 - 01 1160.699951 1172.839966 886.119995 1056.780029 1056.780029 509945100.0 30 days 2022 - 01 - 01 1147.750000 1208.000000 792.010010 936.719971 936.719971 638471400.0 30 days 2022 - 02 - 01 935.210022 947.770020 850.700012 875.760010 875.760010 223112600.0 30 days 2022 - 02 - 15 900.000000 923.000000 893.377380 922.429993 922.429993 19085243.0 30 days [ 141 rows x 7 columns ] Download stock news: import asyncio from pstock import News news = asyncio . run ( News . get ( \"TSLA\" )) print ( news . df ) title url summary date 2022 - 02 - 15 12 : 11 : 46 + 00 : 00 Retail investor : 'I' m being careful just in ca ... https : // finance . yahoo . com / news / retail - investor ... Some retail investors are being more cautious ... 2022 - 02 - 15 12 : 23 : 00 + 00 : 00 Tesla \u2019 s Elon Musk Gave Away $ 5.7 Billion . But ... https : // finance . yahoo . com / m / d342cd56 - d5bb - 3957. .. Tesla CEO Elon Musk gave away more than 5 mill ... 2022 - 02 - 15 13 : 07 : 02 + 00 : 00 Company News for Feb 15 , 2022 https : // finance . yahoo . com / news / company - news - fe ... Companies In The News Are : IFS , OLK , THS , TSLA . .... 2022 - 02 - 15 19 : 23 : 43 + 00 : 00 Australia 's Syrah Resources to expand Louisian... https://finance.yahoo.com/news/australias-syra... Australian industrial materials firm Syrah Res... 2022 - 02 - 15 20 : 31 : 30 + 00 : 00 Biggest Companies in the World by Market Cap https : // finance . yahoo . com / m / 8 aead0a5 - ef35 - 3 d90 ... The world 's biggest companies by market cap op...","title":"Quickstart"},{"location":"#contributors","text":"Feel free to contribute !","title":"Contributors"},{"location":"api/","text":"API pstock special pstock.utils special chart get_ohlc_from_chart ( data : Dict [ str , Any ]) -> List [ Dict [ str , Union [ datetime . datetime , float , datetime . timedelta ]]] Source code in pstock/utils/chart.py def get_ohlc_from_chart ( data : tp . Dict [ str , tp . Any ] ) -> tp . List [ tp . Dict [ str , tp . Union [ datetime , float , timedelta ]]]: result = data . get ( \"chart\" , {}) . get ( \"result\" ) if not result : error = data . get ( \"chart\" , {}) . get ( \"error\" ) if error : raise ValueError ( f \"Yahoo-finance responded with an error: \\n { error } \" ) raise ValueError ( \"Got invalid value for result field in yahoo-finance chart \" f \"response: { result } \" ) result = result [ 0 ] meta = result [ \"meta\" ] interval = parse_duration ( meta [ \"dataGranularity\" ]) symbol = meta [ \"symbol\" ] # Empty chart if \"timestamp\" not in result : logging . getLogger ( __name__ ) . warning ( f \"Yahoo-finance returned an empty chart for symbol ' { symbol } '. \" \"Please make sure that provided params are valid (for example that \" \"start/end times are valid UTC market times).\" ) return [] timestamps = result [ \"timestamp\" ] indicators = result [ \"indicators\" ] ohlc = indicators [ \"quote\" ][ 0 ] volumes = ohlc [ \"volume\" ] opens = ohlc [ \"open\" ] closes = ohlc [ \"close\" ] lows = ohlc [ \"low\" ] highs = ohlc [ \"high\" ] if \"adjclose\" in indicators : adj_closes = indicators [ \"adjclose\" ][ 0 ][ \"adjclose\" ] else : adj_closes = closes return [ { \"date\" : timestamp , \"close\" : close if close is not None else np . nan , \"adj_close\" : adj_close if adj_close is not None else np . nan , \"high\" : high if high is not None else np . nan , \"low\" : low if low is not None else np . nan , \"open\" : open if open is not None else np . nan , \"volume\" : volume if volume is not None else np . nan , \"interval\" : interval , } for timestamp , volume , open , close , adj_close , low , high in zip ( timestamps , volumes , opens , closes , adj_closes , lows , highs ) ] financials_quote get_income_statement_data_from_financials_quote ( financials_quote : Dict [ str , Any ], key : Literal [ 'incomeStatementHistory' , 'incomeStatementHistoryQuarterly' ] = 'incomeStatementHistory' ) -> List [ Dict [ str , Any ]] Source code in pstock/utils/financials_quote.py def get_income_statement_data_from_financials_quote ( financials_quote : tp . Dict [ str , tp . Any ], key : tp . Literal [ \"incomeStatementHistory\" , \"incomeStatementHistoryQuarterly\" ] = \"incomeStatementHistory\" , ) -> tp . List [ tp . Dict [ str , tp . Any ]]: statement_history = financials_quote . get ( key , {}) . get ( \"incomeStatementHistory\" , []) if not statement_history : return [] return [ { \"date\" : statement . get ( \"endDate\" , {}) . get ( \"raw\" ), \"ebit\" : statement . get ( \"ebit\" , {}) . get ( \"raw\" ), \"total_revenue\" : statement . get ( \"totalRevenue\" , {}) . get ( \"raw\" ), \"gross_profit\" : statement . get ( \"grossProfit\" , {}) . get ( \"raw\" ), } for statement in statement_history ] quote get_latest_price_from_quote ( price_data : Dict [ str , Any ]) -> float Source code in pstock/utils/quote.py def get_latest_price_from_quote ( price_data : tp . Dict [ str , tp . Any ]) -> float : if not price_data : raise ValueError ( \"No price data found.\" ) # regular market price regular_market_price = price_data [ \"regularMarketPrice\" ][ \"raw\" ] regular_market_time = pendulum . from_timestamp ( price_data [ \"regularMarketTime\" ]) prices = { \"regular\" : ( regular_market_time , regular_market_price )} # pre-market price pre_market_price = ( price_data . get ( \"preMarketPrice\" , {}) . get ( \"raw\" ) if price_data . get ( \"preMarketPrice\" , {}) is not None else None ) if pre_market_price is not None : prices [ \"pre\" ] = ( pendulum . from_timestamp ( price_data [ \"preMarketTime\" ]), pre_market_price , ) # post-market price post_market_price = ( price_data . get ( \"postMarketPrice\" , {}) . get ( \"raw\" ) if price_data . get ( \"postMarketPrice\" , {}) is not None else None ) if post_market_price is not None : prices [ \"post\" ] = ( pendulum . from_timestamp ( price_data [ \"postMarketTime\" ]), post_market_price , ) _ , ( _ , price ) = min ( prices . items (), key = lambda x : abs ( pendulum . now () - x [ 1 ][ 0 ])) return price get_asset_data_from_quote ( quote : Dict [ str , Any ]) -> Dict [ str , Any ] Source code in pstock/utils/quote.py def get_asset_data_from_quote ( quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: profile = quote . get ( \"summaryProfile\" , {}) or {} quote_type = quote . get ( \"quoteType\" , {}) or {} price_data = quote . get ( \"price\" , {}) or {} symbol = quote . get ( \"symbol\" ) or quote_type . get ( \"symbol\" ) or price_data . get ( \"symbol\" ) name = quote_type . get ( \"longName\" , price_data . get ( \"longName\" )) or quote_type . get ( \"shortName\" , price_data . get ( \"shortName\" ) ) asset_type = quote_type . get ( \"quoteType\" ) or price_data . get ( \"quoteType\" ) currency = price_data . get ( \"currency\" ) latest_price = get_latest_price_from_quote ( price_data ) sector = profile . get ( \"sector\" ) industry = profile . get ( \"industry\" ) return { \"symbol\" : symbol , \"name\" : name , \"asset_type\" : asset_type , \"currency\" : currency , \"latest_price\" : latest_price , \"sector\" : sector , \"industry\" : industry , } get_earnings_data_from_quote ( quote : Dict [ str , Any ]) -> List [ Dict [ str , Union [ str , float ]]] Source code in pstock/utils/quote.py def get_earnings_data_from_quote ( quote : tp . Dict [ str , tp . Any ] ) -> tp . List [ tp . Dict [ str , tp . Union [ str , float ]]]: earnings = quote . get ( \"earnings\" ) if not earnings or not isinstance ( earnings , dict ): return [] earnings_chart = earnings . get ( \"earningsChart\" , {}) quarterly_earnings = earnings_chart . get ( \"quarterly\" , []) quarterly_financial_chart = earnings . get ( \"financialsChart\" , {}) . get ( \"quarterly\" , []) date_to_earnings = { e . get ( \"date\" , \"\" ): { \"actual\" : e . get ( \"actual\" , {}) . get ( \"raw\" , np . nan ), \"estimate\" : e . get ( \"estimate\" , {}) . get ( \"raw\" , np . nan ), } for e in quarterly_earnings if \"date\" in e } date_to_fin_chart = { c . get ( \"date\" , \"\" ): { \"revenue\" : c . get ( \"revenue\" , {}) . get ( \"raw\" , np . nan ), \"earnings\" : c . get ( \"earnings\" , {}) . get ( \"raw\" , np . nan ), } for c in quarterly_financial_chart if \"date\" in c } all_dates = set ( list ( date_to_earnings . keys ()) + list ( date_to_fin_chart . keys ())) passed_earnings = [ dict ( quarter = quarter , actual = date_to_earnings . get ( quarter , {}) . get ( \"actual\" , np . nan ), estimate = date_to_earnings . get ( quarter , {}) . get ( \"estimate\" , np . nan ), revenue = date_to_fin_chart . get ( quarter , {}) . get ( \"revenue\" , np . nan ), earnings = date_to_fin_chart . get ( quarter , {}) . get ( \"earnings\" , np . nan ), ) for quarter in all_dates ] next_earnings = [ dict ( quarter = ( f \" { earnings_chart . get ( 'currentQuarterEstimateDate' , '' ) } \" f \" { earnings_chart . get ( 'currentQuarterEstimateYear' , '' ) } \" ), estimate = earnings_chart . get ( \"currentQuarterEstimate\" , {}) . get ( \"raw\" , np . nan ), actual = np . nan , revenue = np . nan , earnings = np . nan , ) ] return passed_earnings + next_earnings get_trends_data_from_quote ( quote : Dict [ str , Any ]) -> List [ Dict [ str , Any ]] Source code in pstock/utils/quote.py def get_trends_data_from_quote ( quote : tp . Dict [ str , tp . Any ] ) -> tp . List [ tp . Dict [ str , tp . Any ]]: if not quote : return [] recommendation_trend = quote . get ( \"recommendationTrend\" , {}) if not recommendation_trend : return [] trends = recommendation_trend . get ( \"trend\" , []) return [ { \"date\" : date . today () + pendulum . duration ( months = int ( trend [ \"period\" ][: - 1 ])), \"strong_buy\" : trend . get ( \"strongBuy\" , 0 ), \"buy\" : trend . get ( \"buy\" , 0 ), \"hold\" : trend . get ( \"hold\" , 0 ), \"sell\" : trend . get ( \"sell\" , 0 ), \"strong_sell\" : trend . get ( \"stronSell\" , 0 ), } for trend in trends ] utils rdm_user_agent_value () -> str Source code in pstock/utils/utils.py def rdm_user_agent_value () -> str : return random . choice ( _USER_AGENT_LIST ) parse_datetime ( value : Union [ str , int , float , datetime . date , datetime . datetime ]) -> DateTime Source code in pstock/utils/utils.py def parse_datetime ( value : tp . Union [ str , int , float , date , datetime ] ) -> pendulum . DateTime : errors : tp . List [ str ] = [] # try to parse a datetime string, int, bytes if not isinstance ( value , date ): try : return pendulum . instance ( parse_datetime_pydantic ( value )) except ( DateTimeError , TypeError ) as error : errors . append ( str ( error )) # if not above, maybe try to parse a date string, int, bytes object. try : _date = parse_date_pydantic ( value ) return pendulum . datetime ( _date . year , _date . month , _date . day ) except DateError as error : errors . append ( str ( error )) raise ValueError ( f \"Couldn't parse to datetime: { value } : { ', ' . join ( errors ) } \" ) parse_duration ( value : Union [ str , int , float , datetime . timedelta ]) -> Duration Source code in pstock/utils/utils.py def parse_duration ( value : tp . Union [ str , int , float , timedelta ]) -> pendulum . Duration : if isinstance ( value , timedelta ): return pendulum . duration ( seconds = value . total_seconds ()) try : return pendulum . duration ( seconds = parse_duration_pydantic ( value ) . total_seconds ()) except DurationError as error : assert isinstance ( value , str ), str ( error ) if value . lower () == \"mtd\" : return pendulum . duration ( months = 1 ) if value . lower () == \"ytd\" : return pendulum . duration ( years = 1 ) kwargs : tp . Dict [ str , float ] = {} for match in re . finditer ( _UNITS_REGEX , value , flags = re . I ): unit = match . group ( \"unit\" ) . lower () val = match . group ( \"val\" ) if unit not in _UNITS : raise DurationError () name , _type = _UNITS [ unit ] if name in kwargs : kwargs [ name ] += _type ( val ) else : kwargs [ name ] = _type ( val ) if not kwargs : raise DurationError () return pendulum . duration ( ** kwargs ) httpx_client_manager ( client : Optional [ httpx . AsyncClient ] = None ) -> AsyncGenerator [ httpx . AsyncClient , NoneType ] Source code in pstock/utils/utils.py @asynccontextmanager async def httpx_client_manager ( client : tp . Optional [ httpx . AsyncClient ] = None , ) -> tp . AsyncGenerator [ httpx . AsyncClient , None ]: _close = False if client is None : _close = True client = httpx . AsyncClient () try : yield client finally : if _close : await client . aclose () pstock.asset Asset ( QuoteSummary ) pydantic-model Source code in pstock/asset.py class Asset ( QuoteSummary ): symbol : str name : str asset_type : tp . Literal [ \"EQUITY\" , \"CURRENCY\" , \"CRYPTOCURRENCY\" , \"ETF\" , \"FUTURE\" , \"INDEX\" ] currency : str latest_price : float = np . nan sector : tp . Optional [ str ] industry : tp . Optional [ str ] earnings : Earnings = Field ( repr = False ) trends : Trends = Field ( repr = False ) income_statement : tp . Optional [ IncomeStatements ] = Field ( repr = False ) @validator ( \"symbol\" ) def symbol_upper ( cls , symbol : str ) -> str : return symbol . upper () @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: data = get_asset_data_from_quote ( quote ) earnings = Earnings . process_quote ( quote ) trends = Trends . process_quote ( quote ) return { ** data , \"earnings\" : earnings , \"trends\" : trends } @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: income_statement = IncomeStatements . process_financials_quote ( financials_quote ) return { \"income_statement\" : income_statement } symbol : str pydantic-field required name : str pydantic-field required asset_type : Literal [ 'EQUITY' , 'CURRENCY' , 'CRYPTOCURRENCY' , 'ETF' , 'FUTURE' , 'INDEX' ] pydantic-field required currency : str pydantic-field required latest_price : float pydantic-field sector : str pydantic-field industry : str pydantic-field earnings : Earnings pydantic-field required trends : Trends pydantic-field required income_statement : IncomeStatements pydantic-field symbol_upper ( symbol : str ) -> str classmethod Source code in pstock/asset.py @validator ( \"symbol\" ) def symbol_upper ( cls , symbol : str ) -> str : return symbol . upper () process_quote ( quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ] classmethod Source code in pstock/asset.py @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: data = get_asset_data_from_quote ( quote ) earnings = Earnings . process_quote ( quote ) trends = Trends . process_quote ( quote ) return { ** data , \"earnings\" : earnings , \"trends\" : trends } process_financials_quote ( financials_quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ] classmethod Source code in pstock/asset.py @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: income_statement = IncomeStatements . process_financials_quote ( financials_quote ) return { \"income_statement\" : income_statement } Assets ( BaseModelSequence ) pydantic-model Source code in pstock/asset.py class Assets ( BaseModelSequence [ Asset ]): __root__ : tp . List [ Asset ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () df [ \"earnings\" ] = df [ \"earnings\" ] . apply ( lambda v : None if len ( v ) == 0 else v ) df [ \"trends\" ] = df [ \"trends\" ] . apply ( lambda v : None if len ( v ) == 0 else v ) return df . set_index ( \"symbol\" ) . sort_index () . dropna ( axis = 1 , how = \"all\" ) @classmethod async def get ( cls , symbols : tp . List [ str ], * , client : tp . Optional [ httpx . AsyncClient ] = None , ): async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_values = [ tg . soonify ( Asset . get )( symbol , client = _client ) for symbol in symbols ] return cls . parse_obj ([ soon . value for soon in soon_values ]) gen_df ( self ) -> pd . DataFrame Source code in pstock/asset.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () df [ \"earnings\" ] = df [ \"earnings\" ] . apply ( lambda v : None if len ( v ) == 0 else v ) df [ \"trends\" ] = df [ \"trends\" ] . apply ( lambda v : None if len ( v ) == 0 else v ) return df . set_index ( \"symbol\" ) . sort_index () . dropna ( axis = 1 , how = \"all\" ) get ( symbols : tp . List [ str ], * , client : tp . Optional [ httpx . AsyncClient ] = None ) async classmethod Source code in pstock/asset.py @classmethod async def get ( cls , symbols : tp . List [ str ], * , client : tp . Optional [ httpx . AsyncClient ] = None , ): async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_values = [ tg . soonify ( Asset . get )( symbol , client = _client ) for symbol in symbols ] return cls . parse_obj ([ soon . value for soon in soon_values ]) pstock.bar EventParam IntervalParam PeriodParam Bar ( BaseModel ) pydantic-model Source code in pstock/bar.py class Bar ( BaseModel ): date : datetime open : float high : float low : float close : float adj_close : float volume : float interval : timedelta date : datetime pydantic-field required open : float pydantic-field required high : float pydantic-field required low : float pydantic-field required close : float pydantic-field required adj_close : float pydantic-field required volume : float pydantic-field required interval : timedelta pydantic-field required Bars ( BaseModelSequence , _BarMixin ) pydantic-model Source code in pstock/bar.py class Bars ( BaseModelSequence [ Bar ], _BarMixin ): __root__ : tp . List [ Bar ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . dropna ( how = \"all\" , subset = [ \"open\" , \"high\" , \"low\" , \"close\" , \"adj_close\" , \"volume\" ], ) if df [ \"interval\" ][ 0 ] >= timedelta ( days = 1 ): df [ \"date\" ] = pd . to_datetime ( pd . to_datetime ( df [ \"date\" ]) . dt . date ) df = df . set_index ( \"date\" ) . sort_index () return df @classmethod def load ( cls , * , response : tp . Union [ ReadableResponse , str , bytes , dict ], ) -> Bars : if isinstance ( response , dict ): data = response elif isinstance ( response , ( str , bytes )): data = json . loads ( response ) else : data = json . loads ( response . read ()) return cls . parse_obj ( get_ohlc_from_chart ( data )) @classmethod async def get ( cls , symbol : str , * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = \"div,splits\" , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None , ): url = cls . base_uri ( symbol ) params = cls . params ( interval = interval , period = period , start = start , end = end , events = events , include_prepost = include_prepost , ) async with httpx_client_manager ( client = client ) as _client : response = await _client . get ( url , params = params ) return cls . load ( response = response ) gen_df ( self ) -> pd . DataFrame Source code in pstock/bar.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . dropna ( how = \"all\" , subset = [ \"open\" , \"high\" , \"low\" , \"close\" , \"adj_close\" , \"volume\" ], ) if df [ \"interval\" ][ 0 ] >= timedelta ( days = 1 ): df [ \"date\" ] = pd . to_datetime ( pd . to_datetime ( df [ \"date\" ]) . dt . date ) df = df . set_index ( \"date\" ) . sort_index () return df load ( * , response : tp . Union [ ReadableResponse , str , bytes , dict ]) -> Bars classmethod Source code in pstock/bar.py @classmethod def load ( cls , * , response : tp . Union [ ReadableResponse , str , bytes , dict ], ) -> Bars : if isinstance ( response , dict ): data = response elif isinstance ( response , ( str , bytes )): data = json . loads ( response ) else : data = json . loads ( response . read ()) return cls . parse_obj ( get_ohlc_from_chart ( data )) get ( symbol : str , * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = 'div,splits' , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None ) async classmethod Source code in pstock/bar.py @classmethod async def get ( cls , symbol : str , * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = \"div,splits\" , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None , ): url = cls . base_uri ( symbol ) params = cls . params ( interval = interval , period = period , start = start , end = end , events = events , include_prepost = include_prepost , ) async with httpx_client_manager ( client = client ) as _client : response = await _client . get ( url , params = params ) return cls . load ( response = response ) BarsMulti ( BaseModelMapping , _BarMixin ) pydantic-model Source code in pstock/bar.py class BarsMulti ( BaseModelMapping [ Bars ], _BarMixin ): __root__ : tp . Dict [ str , Bars ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () return df . sort_index () @classmethod async def get ( cls , symbols : tp . List [ str ], * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = \"div,splits\" , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None , ): async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_values = [ tg . soonify ( Bars . get )( symbol , interval = interval , period = period , start = start , end = end , include_prepost = include_prepost , events = events , client = _client , ) for symbol in symbols ] data = { symbol : soon_value . value for symbol , soon_value in zip ( symbols , soon_values ) } return cls . parse_obj ( data ) gen_df ( self ) -> pd . DataFrame Source code in pstock/bar.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () return df . sort_index () get ( symbols : tp . List [ str ], * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = 'div,splits' , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None ) async classmethod Source code in pstock/bar.py @classmethod async def get ( cls , symbols : tp . List [ str ], * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = \"div,splits\" , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None , ): async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_values = [ tg . soonify ( Bars . get )( symbol , interval = interval , period = period , start = start , end = end , include_prepost = include_prepost , events = events , client = _client , ) for symbol in symbols ] data = { symbol : soon_value . value for symbol , soon_value in zip ( symbols , soon_values ) } return cls . parse_obj ( data ) pstock.base T U BaseModel ( BaseModel ) pydantic-model Source code in pstock/base.py class BaseModel ( _BaseModel ): _created_at : datetime = PrivateAttr ( default_factory = pendulum . now ) @property def created_at ( self ) -> datetime : return self . _created_at created_at : datetime property readonly BaseModelDf ( BaseModel , ABC ) pydantic-model Source code in pstock/base.py class BaseModelDf ( BaseModel , ABC ): _df : tp . Optional [ pd . DataFrame ] = PrivateAttr ( default = None ) @abstractmethod def gen_df ( self ) -> pd . DataFrame : ... @property def df ( self ) -> pd . DataFrame : if self . _df is None : self . _df = self . gen_df () return self . _df df : pd . DataFrame property readonly gen_df ( self ) -> pd . DataFrame Source code in pstock/base.py @abstractmethod def gen_df ( self ) -> pd . DataFrame : ... BaseModelSequence ( Generic , BaseModelDf ) pydantic-model Source code in pstock/base.py class BaseModelSequence ( tp . Generic [ T ], BaseModelDf ): __root__ : tp . Sequence [ T ] @tp . overload def __getitem__ ( self , index : int ) -> T : \"\"\"Get single item from __root__ by idx.\"\"\" @tp . overload def __getitem__ ( self , index : slice ) -> tp . Sequence [ T ]: \"\"\"Get slice of items from __root__ by idx.\"\"\" def __getitem__ ( self , index ): return self . __root__ [ index ] def __len__ ( self ) -> int : return len ( self . __root__ ) def __iter__ ( self ) -> tp . Iterator [ T ]: # type: ignore return iter ( self . __root__ ) def gen_df ( self ) -> pd . DataFrame : return pd . DataFrame . from_dict ( self . dict () . get ( \"__root__\" ), orient = \"columns\" ) __root__ : Sequence [ ~ T ] pydantic-field required special gen_df ( self ) -> pd . DataFrame Source code in pstock/base.py def gen_df ( self ) -> pd . DataFrame : return pd . DataFrame . from_dict ( self . dict () . get ( \"__root__\" ), orient = \"columns\" ) BaseModelMapping ( Generic , BaseModelDf ) pydantic-model Source code in pstock/base.py class BaseModelMapping ( tp . Generic [ U ], BaseModelDf ): __root__ : tp . Mapping [ str , U ] def __getitem__ ( self , index : str ) -> U : return self . __root__ [ index ] def __len__ ( self ) -> int : return len ( self . __root__ ) def __iter__ ( self ) -> tp . Iterator [ str ]: # type: ignore return iter ( self . __root__ ) def gen_df ( self ) -> pd . DataFrame : keys , dfs = zip ( * [( key , value . df ) for key , value in self . __root__ . items ()]) return pd . concat ( dfs , axis = 1 , keys = keys ) __root__ : Mapping [ str , ~ U ] pydantic-field required special gen_df ( self ) -> pd . DataFrame Source code in pstock/base.py def gen_df ( self ) -> pd . DataFrame : keys , dfs = zip ( * [( key , value . df ) for key , value in self . __root__ . items ()]) return pd . concat ( dfs , axis = 1 , keys = keys ) pstock.earnings Earning ( BaseModel ) pydantic-model Source code in pstock/earnings.py class Earning ( BaseModel ): quarter : str estimate : float actual : float status : tp . Literal [ None , \"Beat\" , \"Missed\" ] = None revenue : float earnings : float @validator ( \"status\" , always = True ) def set_status ( cls , value : tp . Any , values : tp . Dict [ str , tp . Any ] ) -> tp . Literal [ None , \"Beat\" , \"Missed\" ]: if value is not None : return value estimate = values . get ( \"estimate\" ) actual = values . get ( \"actual\" ) if actual is None or np . isnan ( actual ) or estimate is None or np . isnan ( estimate ): return None return \"Beat\" if actual >= estimate else \"Missed\" quarter : str pydantic-field required estimate : float pydantic-field required actual : float pydantic-field required status : Literal [ None , 'Beat' , 'Missed' ] pydantic-field revenue : float pydantic-field required earnings : float pydantic-field required set_status ( value : Any , values : Dict [ str , Any ]) -> Literal [ None , 'Beat' , 'Missed' ] classmethod Source code in pstock/earnings.py @validator ( \"status\" , always = True ) def set_status ( cls , value : tp . Any , values : tp . Dict [ str , tp . Any ] ) -> tp . Literal [ None , \"Beat\" , \"Missed\" ]: if value is not None : return value estimate = values . get ( \"estimate\" ) actual = values . get ( \"actual\" ) if actual is None or np . isnan ( actual ) or estimate is None or np . isnan ( estimate ): return None return \"Beat\" if actual >= estimate else \"Missed\" Earnings ( BaseModelSequence , QuoteSummary ) pydantic-model Source code in pstock/earnings.py class Earnings ( BaseModelSequence [ Earning ], QuoteSummary ): __root__ : tp . List [ Earning ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"quarter\" ) . sort_index ( key = pd . to_datetime ) return df @validator ( \"__root__\" ) def sort_earnings ( cls , value : tp . List [ Earning ]) -> tp . List [ Earning ]: if not value : return value return sorted ( value , key = lambda earning : pd . to_datetime ( earning . quarter )) @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_earnings_data_from_quote ( quote )} gen_df ( self ) -> DataFrame Source code in pstock/earnings.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"quarter\" ) . sort_index ( key = pd . to_datetime ) return df sort_earnings ( value : List [ pstock . earnings . Earning ]) -> List [ pstock . earnings . Earning ] classmethod Source code in pstock/earnings.py @validator ( \"__root__\" ) def sort_earnings ( cls , value : tp . List [ Earning ]) -> tp . List [ Earning ]: if not value : return value return sorted ( value , key = lambda earning : pd . to_datetime ( earning . quarter )) process_quote ( quote : Dict [ str , Any ]) -> Dict [ str , Any ] classmethod Source code in pstock/earnings.py @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_earnings_data_from_quote ( quote )} pstock.income_statement IncomeStatement ( BaseModel ) pydantic-model Source code in pstock/income_statement.py class IncomeStatement ( BaseModel ): date : date ebit : float total_revenue : float gross_profit : float date : date pydantic-field required ebit : float pydantic-field required total_revenue : float pydantic-field required gross_profit : float pydantic-field required BaseIncomeStatements ( BaseModelSequence , QuoteSummary ) pydantic-model Source code in pstock/income_statement.py class BaseIncomeStatements ( BaseModelSequence [ IncomeStatement ], QuoteSummary ): __root__ : tp . List [ IncomeStatement ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df gen_df ( self ) -> DataFrame Source code in pstock/income_statement.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df IncomeStatements ( BaseIncomeStatements ) pydantic-model Source code in pstock/income_statement.py class IncomeStatements ( BaseIncomeStatements ): @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_income_statement_data_from_financials_quote ( financials_quote , key = \"incomeStatementHistory\" ) } @property def revenue_compound_annual_growth_rate ( self ) -> float : \"\"\"Revenue CAGR. https://www.investopedia.com/terms/c/cagr.asp Returns: float: Revenue CAGR based \"\"\" latest_revenue = self . df . max ()[ \"total_revenue\" ] earliest_revenue = self . df . min ()[ \"total_revenue\" ] num_years = len ( self . df ) - 1 return ( latest_revenue / earliest_revenue ) ** ( 1 / num_years ) - 1 revenue_compound_annual_growth_rate : float property readonly Revenue CAGR. https://www.investopedia.com/terms/c/cagr.asp Returns: Type Description float Revenue CAGR based process_financials_quote ( financials_quote : Dict [ str , Any ]) -> Dict [ str , Any ] classmethod Source code in pstock/income_statement.py @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_income_statement_data_from_financials_quote ( financials_quote , key = \"incomeStatementHistory\" ) } QuarterlyIncomeStatements ( BaseIncomeStatements ) pydantic-model Source code in pstock/income_statement.py class QuarterlyIncomeStatements ( BaseIncomeStatements ): @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_income_statement_data_from_financials_quote ( financials_quote , key = \"incomeStatementHistoryQuarterly\" ) } @property def revenue_compound_annual_growth_rate ( self ) -> float : raise NotImplementedError () revenue_compound_annual_growth_rate : float property readonly process_financials_quote ( financials_quote : Dict [ str , Any ]) -> Dict [ str , Any ] classmethod Source code in pstock/income_statement.py @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_income_statement_data_from_financials_quote ( financials_quote , key = \"incomeStatementHistoryQuarterly\" ) } pstock.news Publication ( BaseModel ) pydantic-model Source code in pstock/news.py class Publication ( BaseModel ): date : datetime . datetime title : str url : str summary : tp . Optional [ str ] date : datetime pydantic-field required title : str pydantic-field required url : str pydantic-field required summary : str pydantic-field News ( BaseModelSequence ) pydantic-model Source code in pstock/news.py class News ( BaseModelSequence ): __root__ : tp . List [ Publication ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df @staticmethod def base_uri () -> str : return \"https://feeds.finance.yahoo.com/rss/2.0/headline\" @staticmethod def params ( symbol : str ) -> tp . Dict [ str , str ]: return { \"s\" : symbol . upper (), \"region\" : \"US\" , \"lang\" : \"en-US\" } @classmethod def uri ( cls , symbol : str ) -> str : return f \" { cls . base_uri () } ? { urlencode ( cls . params ( symbol )) } \" @classmethod def load ( cls , * , symbol : tp . Optional [ str ] = None , response : tp . Union [ None , str , bytes , ReadableResponse ] = None , ) -> News : if symbol is not None and response is None : # feedparser can take a uri as input, and get data over http response = cls . uri ( symbol ) print ( response ) if response is None : raise ValueError ( \"Please provide either a symbol or or a readeable response.\" ) feed = feedparser . parse ( response ) return cls . parse_obj ( [ { ** entry , \"date\" : time . mktime ( entry [ \"published_parsed\" ]), \"url\" : entry [ \"link\" ], } for entry in feed . entries ] ) @classmethod async def get ( cls , symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None , ) -> News : async with httpx_client_manager ( client = client ) as _client : response = await _client . get ( cls . base_uri (), params = cls . params ( symbol )) return cls . load ( response = response ) gen_df ( self ) -> pd . DataFrame Source code in pstock/news.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df base_uri () -> str staticmethod Source code in pstock/news.py @staticmethod def base_uri () -> str : return \"https://feeds.finance.yahoo.com/rss/2.0/headline\" params ( symbol : str ) -> tp . Dict [ str , str ] staticmethod Source code in pstock/news.py @staticmethod def params ( symbol : str ) -> tp . Dict [ str , str ]: return { \"s\" : symbol . upper (), \"region\" : \"US\" , \"lang\" : \"en-US\" } uri ( symbol : str ) -> str classmethod Source code in pstock/news.py @classmethod def uri ( cls , symbol : str ) -> str : return f \" { cls . base_uri () } ? { urlencode ( cls . params ( symbol )) } \" load ( * , symbol : tp . Optional [ str ] = None , response : tp . Union [ None , str , bytes , ReadableResponse ] = None ) -> News classmethod Source code in pstock/news.py @classmethod def load ( cls , * , symbol : tp . Optional [ str ] = None , response : tp . Union [ None , str , bytes , ReadableResponse ] = None , ) -> News : if symbol is not None and response is None : # feedparser can take a uri as input, and get data over http response = cls . uri ( symbol ) print ( response ) if response is None : raise ValueError ( \"Please provide either a symbol or or a readeable response.\" ) feed = feedparser . parse ( response ) return cls . parse_obj ( [ { ** entry , \"date\" : time . mktime ( entry [ \"published_parsed\" ]), \"url\" : entry [ \"link\" ], } for entry in feed . entries ] ) get ( symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None ) -> News async classmethod Source code in pstock/news.py @classmethod async def get ( cls , symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None , ) -> News : async with httpx_client_manager ( client = client ) as _client : response = await _client . get ( cls . base_uri (), params = cls . params ( symbol )) return cls . load ( response = response ) pstock.quote T QuoteSummary ( BaseModel ) pydantic-model Source code in pstock/quote.py class QuoteSummary ( BaseModel ): @staticmethod def uri ( symbol : str ) -> str : return f \"https://finance.yahoo.com/quote/ { symbol . upper () } \" @staticmethod def financials_uri ( symbol : str ) -> str : return ( f \"https://finance.yahoo.com/quote/ { symbol . upper () } /\" f \"financials?p= { symbol . upper () } \" ) @staticmethod def parse_quote ( response : tp . Union [ ReadableResponse , str , bytes ] ) -> tp . Dict [ str , tp . Any ]: content = response if isinstance ( response , ( str , bytes )) else response . read () soup = BeautifulSoup ( content , \"html.parser\" ) script = soup . find ( \"script\" , text = re . compile ( r \"root.App.main\" )) if script is None : return {} match = re . search ( r \"root.App.main\\s+=\\s+(\\{.*\\})\" , script . text ) if match is None : return {} data : tp . Dict [ str , tp . Any ] = json . loads ( match . group ( 1 )) return ( data . get ( \"context\" , {}) . get ( \"dispatcher\" , {}) . get ( \"stores\" , {}) . get ( \"QuoteSummaryStore\" , {}) ) @classmethod def process_quote ( cls : tp . Type [ T ], quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return {} @classmethod def process_financials_quote ( cls : tp . Type [ T ], financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return {} @classmethod def load ( cls : tp . Type [ T ], * , response : tp . Union [ ReadableResponse , str , bytes , None ] = None , financials_response : tp . Union [ ReadableResponse , str , bytes , None ] = None , ) -> T : data = {} _quote = None _financials_quote = None if response is not None : _quote = cls . parse_quote ( response ) if _quote : data . update ( cls . process_quote ( _quote )) if financials_response is not None : _financials_quote = cls . parse_quote ( financials_response ) if _financials_quote : data . update ( cls . process_financials_quote ( _financials_quote )) return cls ( ** data ) @classmethod async def get ( cls : tp . Type [ T ], symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None , ) -> T : async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_quote = tg . soonify ( _client . get )( cls . uri ( symbol ), headers = { \"user-agent\" : rdm_user_agent_value ()} ) soon_financials = tg . soonify ( _client . get )( cls . financials_uri ( symbol ), headers = { \"user-agent\" : rdm_user_agent_value ()}, ) return cls . load ( response = soon_quote . value , financials_response = soon_financials . value ) uri ( symbol : str ) -> str staticmethod Source code in pstock/quote.py @staticmethod def uri ( symbol : str ) -> str : return f \"https://finance.yahoo.com/quote/ { symbol . upper () } \" financials_uri ( symbol : str ) -> str staticmethod Source code in pstock/quote.py @staticmethod def financials_uri ( symbol : str ) -> str : return ( f \"https://finance.yahoo.com/quote/ { symbol . upper () } /\" f \"financials?p= { symbol . upper () } \" ) parse_quote ( response : Union [ pstock . types . ReadableResponse , str , bytes ]) -> Dict [ str , Any ] staticmethod Source code in pstock/quote.py @staticmethod def parse_quote ( response : tp . Union [ ReadableResponse , str , bytes ] ) -> tp . Dict [ str , tp . Any ]: content = response if isinstance ( response , ( str , bytes )) else response . read () soup = BeautifulSoup ( content , \"html.parser\" ) script = soup . find ( \"script\" , text = re . compile ( r \"root.App.main\" )) if script is None : return {} match = re . search ( r \"root.App.main\\s+=\\s+(\\{.*\\})\" , script . text ) if match is None : return {} data : tp . Dict [ str , tp . Any ] = json . loads ( match . group ( 1 )) return ( data . get ( \"context\" , {}) . get ( \"dispatcher\" , {}) . get ( \"stores\" , {}) . get ( \"QuoteSummaryStore\" , {}) ) process_quote ( quote : Dict [ str , Any ]) -> Dict [ str , Any ] classmethod Source code in pstock/quote.py @classmethod def process_quote ( cls : tp . Type [ T ], quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return {} process_financials_quote ( financials_quote : Dict [ str , Any ]) -> Dict [ str , Any ] classmethod Source code in pstock/quote.py @classmethod def process_financials_quote ( cls : tp . Type [ T ], financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return {} load ( * , response : Union [ pstock . types . ReadableResponse , str , bytes ] = None , financials_response : Union [ pstock . types . ReadableResponse , str , bytes ] = None ) -> ~ T classmethod Source code in pstock/quote.py @classmethod def load ( cls : tp . Type [ T ], * , response : tp . Union [ ReadableResponse , str , bytes , None ] = None , financials_response : tp . Union [ ReadableResponse , str , bytes , None ] = None , ) -> T : data = {} _quote = None _financials_quote = None if response is not None : _quote = cls . parse_quote ( response ) if _quote : data . update ( cls . process_quote ( _quote )) if financials_response is not None : _financials_quote = cls . parse_quote ( financials_response ) if _financials_quote : data . update ( cls . process_financials_quote ( _financials_quote )) return cls ( ** data ) get ( symbol : str , * , client : Optional [ httpx . AsyncClient ] = None ) -> ~ T async classmethod Source code in pstock/quote.py @classmethod async def get ( cls : tp . Type [ T ], symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None , ) -> T : async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_quote = tg . soonify ( _client . get )( cls . uri ( symbol ), headers = { \"user-agent\" : rdm_user_agent_value ()} ) soon_financials = tg . soonify ( _client . get )( cls . financials_uri ( symbol ), headers = { \"user-agent\" : rdm_user_agent_value ()}, ) return cls . load ( response = soon_quote . value , financials_response = soon_financials . value ) pstock.trend Trend ( BaseModel ) pydantic-model Source code in pstock/trend.py class Trend ( BaseModel ): date : datetime . date strong_buy : int = 0 buy : int = 0 hold : int = 0 sell : int = 0 strong_sell : int = 0 score : tp . Optional [ float ] = None recomendation : tp . Literal [ None , \"STRONG_BUY\" , \"BUY\" , \"HOLD\" , \"SELL\" , \"STRONG_SELL\" ] = None @validator ( \"score\" , always = True ) def compute_score ( cls , value : tp . Optional [ float ], values : tp . Dict [ str , tp . Any ] ) -> float : if value is not None : return value numerator = ( values [ \"strong_buy\" ] + values [ \"buy\" ] * 2 + values [ \"hold\" ] * 3 + values [ \"sell\" ] * 4 + values [ \"strong_sell\" ] * 5 ) denominator = ( values [ \"strong_buy\" ] + values [ \"buy\" ] + values [ \"hold\" ] + values [ \"sell\" ] + values [ \"strong_sell\" ] ) if denominator == 0 : return np . nan return round ( numerator / denominator , 2 ) @validator ( \"recomendation\" , always = True ) def compute_recomendation ( cls , value : tp . Optional [ float ], values : tp . Dict [ str , tp . Any ] ): if value is not None : return value score = values [ \"score\" ] if np . isnan ( score ): return \"UNKNOWN\" elif score >= 4.5 : return \"STRONG_SELL\" elif score >= 3.5 : return \"SELL\" elif score >= 2.5 : return \"HOLD\" elif score >= 1.5 : return \"BUY\" else : return \"STRONG_BUY\" date : date pydantic-field required strong_buy : int pydantic-field buy : int pydantic-field hold : int pydantic-field sell : int pydantic-field strong_sell : int pydantic-field score : float pydantic-field recomendation : Literal [ None , 'STRONG_BUY' , 'BUY' , 'HOLD' , 'SELL' , 'STRONG_SELL' ] pydantic-field compute_score ( value : Optional [ float ], values : Dict [ str , Any ]) -> float classmethod Source code in pstock/trend.py @validator ( \"score\" , always = True ) def compute_score ( cls , value : tp . Optional [ float ], values : tp . Dict [ str , tp . Any ] ) -> float : if value is not None : return value numerator = ( values [ \"strong_buy\" ] + values [ \"buy\" ] * 2 + values [ \"hold\" ] * 3 + values [ \"sell\" ] * 4 + values [ \"strong_sell\" ] * 5 ) denominator = ( values [ \"strong_buy\" ] + values [ \"buy\" ] + values [ \"hold\" ] + values [ \"sell\" ] + values [ \"strong_sell\" ] ) if denominator == 0 : return np . nan return round ( numerator / denominator , 2 ) compute_recomendation ( value : Optional [ float ], values : Dict [ str , Any ]) classmethod Source code in pstock/trend.py @validator ( \"recomendation\" , always = True ) def compute_recomendation ( cls , value : tp . Optional [ float ], values : tp . Dict [ str , tp . Any ] ): if value is not None : return value score = values [ \"score\" ] if np . isnan ( score ): return \"UNKNOWN\" elif score >= 4.5 : return \"STRONG_SELL\" elif score >= 3.5 : return \"SELL\" elif score >= 2.5 : return \"HOLD\" elif score >= 1.5 : return \"BUY\" else : return \"STRONG_BUY\" Trends ( BaseModelSequence , QuoteSummary ) pydantic-model Source code in pstock/trend.py class Trends ( BaseModelSequence [ Trend ], QuoteSummary ): __root__ : tp . List [ Trend ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df @validator ( \"__root__\" ) def sort_trends ( cls , value : tp . List [ Trend ]) -> tp . List [ Trend ]: if not value : return value return sorted ( value , key = lambda trend : pd . to_datetime ( trend . date )) @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_trends_data_from_quote ( quote )} gen_df ( self ) -> DataFrame Source code in pstock/trend.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df sort_trends ( value : List [ pstock . trend . Trend ]) -> List [ pstock . trend . Trend ] classmethod Source code in pstock/trend.py @validator ( \"__root__\" ) def sort_trends ( cls , value : tp . List [ Trend ]) -> tp . List [ Trend ]: if not value : return value return sorted ( value , key = lambda trend : pd . to_datetime ( trend . date )) process_quote ( quote : Dict [ str , Any ]) -> Dict [ str , Any ] classmethod Source code in pstock/trend.py @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_trends_data_from_quote ( quote )} pstock.types Timestamp ( int ) Source code in pstock/types.py class Timestamp ( int ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , value : tp . Union [ str , int , float , date , datetime ]) -> int : return parse_datetime ( value ) . int_timestamp validate ( value : Union [ str , int , float , datetime . date , datetime . datetime ]) -> int classmethod Source code in pstock/types.py @classmethod def validate ( cls , value : tp . Union [ str , int , float , date , datetime ]) -> int : return parse_datetime ( value ) . int_timestamp ReadableResponse ( Protocol ) Source code in pstock/types.py class ReadableResponse ( tp . Protocol ): def read ( self ) -> tp . Union [ str , bytes ]: ... read ( self ) -> Union [ str , bytes ] Source code in pstock/types.py def read ( self ) -> tp . Union [ str , bytes ]: ... __init__ ( self , * args , ** kwargs ) special Source code in pstock/types.py def _no_init_or_replace_init ( self , * args , ** kwargs ): cls = type ( self ) if cls . _is_protocol : raise TypeError ( 'Protocols cannot be instantiated' ) # Already using a custom `__init__`. No need to calculate correct # `__init__` to call. This can lead to RecursionError. See bpo-45121. if cls . __init__ is not _no_init_or_replace_init : return # Initially, `__init__` of a protocol subclass is set to `_no_init_or_replace_init`. # The first instantiation of the subclass will call `_no_init_or_replace_init` which # searches for a proper new `__init__` in the MRO. The new `__init__` # replaces the subclass' old `__init__` (ie `_no_init_or_replace_init`). Subsequent # instantiation of the protocol subclass will thus use the new # `__init__` and no longer call `_no_init_or_replace_init`. for base in cls . __mro__ : init = base . __dict__ . get ( '__init__' , _no_init_or_replace_init ) if init is not _no_init_or_replace_init : cls . __init__ = init break else : # should not happen cls . __init__ = object . __init__ cls . __init__ ( self , * args , ** kwargs )","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#pstock","text":"","title":"pstock"},{"location":"api/#pstock.utils","text":"","title":"utils"},{"location":"api/#pstock.utils.chart","text":"","title":"chart"},{"location":"api/#pstock.utils.chart.get_ohlc_from_chart","text":"Source code in pstock/utils/chart.py def get_ohlc_from_chart ( data : tp . Dict [ str , tp . Any ] ) -> tp . List [ tp . Dict [ str , tp . Union [ datetime , float , timedelta ]]]: result = data . get ( \"chart\" , {}) . get ( \"result\" ) if not result : error = data . get ( \"chart\" , {}) . get ( \"error\" ) if error : raise ValueError ( f \"Yahoo-finance responded with an error: \\n { error } \" ) raise ValueError ( \"Got invalid value for result field in yahoo-finance chart \" f \"response: { result } \" ) result = result [ 0 ] meta = result [ \"meta\" ] interval = parse_duration ( meta [ \"dataGranularity\" ]) symbol = meta [ \"symbol\" ] # Empty chart if \"timestamp\" not in result : logging . getLogger ( __name__ ) . warning ( f \"Yahoo-finance returned an empty chart for symbol ' { symbol } '. \" \"Please make sure that provided params are valid (for example that \" \"start/end times are valid UTC market times).\" ) return [] timestamps = result [ \"timestamp\" ] indicators = result [ \"indicators\" ] ohlc = indicators [ \"quote\" ][ 0 ] volumes = ohlc [ \"volume\" ] opens = ohlc [ \"open\" ] closes = ohlc [ \"close\" ] lows = ohlc [ \"low\" ] highs = ohlc [ \"high\" ] if \"adjclose\" in indicators : adj_closes = indicators [ \"adjclose\" ][ 0 ][ \"adjclose\" ] else : adj_closes = closes return [ { \"date\" : timestamp , \"close\" : close if close is not None else np . nan , \"adj_close\" : adj_close if adj_close is not None else np . nan , \"high\" : high if high is not None else np . nan , \"low\" : low if low is not None else np . nan , \"open\" : open if open is not None else np . nan , \"volume\" : volume if volume is not None else np . nan , \"interval\" : interval , } for timestamp , volume , open , close , adj_close , low , high in zip ( timestamps , volumes , opens , closes , adj_closes , lows , highs ) ]","title":"get_ohlc_from_chart()"},{"location":"api/#pstock.utils.financials_quote","text":"","title":"financials_quote"},{"location":"api/#pstock.utils.financials_quote.get_income_statement_data_from_financials_quote","text":"Source code in pstock/utils/financials_quote.py def get_income_statement_data_from_financials_quote ( financials_quote : tp . Dict [ str , tp . Any ], key : tp . Literal [ \"incomeStatementHistory\" , \"incomeStatementHistoryQuarterly\" ] = \"incomeStatementHistory\" , ) -> tp . List [ tp . Dict [ str , tp . Any ]]: statement_history = financials_quote . get ( key , {}) . get ( \"incomeStatementHistory\" , []) if not statement_history : return [] return [ { \"date\" : statement . get ( \"endDate\" , {}) . get ( \"raw\" ), \"ebit\" : statement . get ( \"ebit\" , {}) . get ( \"raw\" ), \"total_revenue\" : statement . get ( \"totalRevenue\" , {}) . get ( \"raw\" ), \"gross_profit\" : statement . get ( \"grossProfit\" , {}) . get ( \"raw\" ), } for statement in statement_history ]","title":"get_income_statement_data_from_financials_quote()"},{"location":"api/#pstock.utils.quote","text":"","title":"quote"},{"location":"api/#pstock.utils.quote.get_latest_price_from_quote","text":"Source code in pstock/utils/quote.py def get_latest_price_from_quote ( price_data : tp . Dict [ str , tp . Any ]) -> float : if not price_data : raise ValueError ( \"No price data found.\" ) # regular market price regular_market_price = price_data [ \"regularMarketPrice\" ][ \"raw\" ] regular_market_time = pendulum . from_timestamp ( price_data [ \"regularMarketTime\" ]) prices = { \"regular\" : ( regular_market_time , regular_market_price )} # pre-market price pre_market_price = ( price_data . get ( \"preMarketPrice\" , {}) . get ( \"raw\" ) if price_data . get ( \"preMarketPrice\" , {}) is not None else None ) if pre_market_price is not None : prices [ \"pre\" ] = ( pendulum . from_timestamp ( price_data [ \"preMarketTime\" ]), pre_market_price , ) # post-market price post_market_price = ( price_data . get ( \"postMarketPrice\" , {}) . get ( \"raw\" ) if price_data . get ( \"postMarketPrice\" , {}) is not None else None ) if post_market_price is not None : prices [ \"post\" ] = ( pendulum . from_timestamp ( price_data [ \"postMarketTime\" ]), post_market_price , ) _ , ( _ , price ) = min ( prices . items (), key = lambda x : abs ( pendulum . now () - x [ 1 ][ 0 ])) return price","title":"get_latest_price_from_quote()"},{"location":"api/#pstock.utils.quote.get_asset_data_from_quote","text":"Source code in pstock/utils/quote.py def get_asset_data_from_quote ( quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: profile = quote . get ( \"summaryProfile\" , {}) or {} quote_type = quote . get ( \"quoteType\" , {}) or {} price_data = quote . get ( \"price\" , {}) or {} symbol = quote . get ( \"symbol\" ) or quote_type . get ( \"symbol\" ) or price_data . get ( \"symbol\" ) name = quote_type . get ( \"longName\" , price_data . get ( \"longName\" )) or quote_type . get ( \"shortName\" , price_data . get ( \"shortName\" ) ) asset_type = quote_type . get ( \"quoteType\" ) or price_data . get ( \"quoteType\" ) currency = price_data . get ( \"currency\" ) latest_price = get_latest_price_from_quote ( price_data ) sector = profile . get ( \"sector\" ) industry = profile . get ( \"industry\" ) return { \"symbol\" : symbol , \"name\" : name , \"asset_type\" : asset_type , \"currency\" : currency , \"latest_price\" : latest_price , \"sector\" : sector , \"industry\" : industry , }","title":"get_asset_data_from_quote()"},{"location":"api/#pstock.utils.quote.get_earnings_data_from_quote","text":"Source code in pstock/utils/quote.py def get_earnings_data_from_quote ( quote : tp . Dict [ str , tp . Any ] ) -> tp . List [ tp . Dict [ str , tp . Union [ str , float ]]]: earnings = quote . get ( \"earnings\" ) if not earnings or not isinstance ( earnings , dict ): return [] earnings_chart = earnings . get ( \"earningsChart\" , {}) quarterly_earnings = earnings_chart . get ( \"quarterly\" , []) quarterly_financial_chart = earnings . get ( \"financialsChart\" , {}) . get ( \"quarterly\" , []) date_to_earnings = { e . get ( \"date\" , \"\" ): { \"actual\" : e . get ( \"actual\" , {}) . get ( \"raw\" , np . nan ), \"estimate\" : e . get ( \"estimate\" , {}) . get ( \"raw\" , np . nan ), } for e in quarterly_earnings if \"date\" in e } date_to_fin_chart = { c . get ( \"date\" , \"\" ): { \"revenue\" : c . get ( \"revenue\" , {}) . get ( \"raw\" , np . nan ), \"earnings\" : c . get ( \"earnings\" , {}) . get ( \"raw\" , np . nan ), } for c in quarterly_financial_chart if \"date\" in c } all_dates = set ( list ( date_to_earnings . keys ()) + list ( date_to_fin_chart . keys ())) passed_earnings = [ dict ( quarter = quarter , actual = date_to_earnings . get ( quarter , {}) . get ( \"actual\" , np . nan ), estimate = date_to_earnings . get ( quarter , {}) . get ( \"estimate\" , np . nan ), revenue = date_to_fin_chart . get ( quarter , {}) . get ( \"revenue\" , np . nan ), earnings = date_to_fin_chart . get ( quarter , {}) . get ( \"earnings\" , np . nan ), ) for quarter in all_dates ] next_earnings = [ dict ( quarter = ( f \" { earnings_chart . get ( 'currentQuarterEstimateDate' , '' ) } \" f \" { earnings_chart . get ( 'currentQuarterEstimateYear' , '' ) } \" ), estimate = earnings_chart . get ( \"currentQuarterEstimate\" , {}) . get ( \"raw\" , np . nan ), actual = np . nan , revenue = np . nan , earnings = np . nan , ) ] return passed_earnings + next_earnings","title":"get_earnings_data_from_quote()"},{"location":"api/#pstock.utils.quote.get_trends_data_from_quote","text":"Source code in pstock/utils/quote.py def get_trends_data_from_quote ( quote : tp . Dict [ str , tp . Any ] ) -> tp . List [ tp . Dict [ str , tp . Any ]]: if not quote : return [] recommendation_trend = quote . get ( \"recommendationTrend\" , {}) if not recommendation_trend : return [] trends = recommendation_trend . get ( \"trend\" , []) return [ { \"date\" : date . today () + pendulum . duration ( months = int ( trend [ \"period\" ][: - 1 ])), \"strong_buy\" : trend . get ( \"strongBuy\" , 0 ), \"buy\" : trend . get ( \"buy\" , 0 ), \"hold\" : trend . get ( \"hold\" , 0 ), \"sell\" : trend . get ( \"sell\" , 0 ), \"strong_sell\" : trend . get ( \"stronSell\" , 0 ), } for trend in trends ]","title":"get_trends_data_from_quote()"},{"location":"api/#pstock.utils.utils","text":"","title":"utils"},{"location":"api/#pstock.utils.utils.rdm_user_agent_value","text":"Source code in pstock/utils/utils.py def rdm_user_agent_value () -> str : return random . choice ( _USER_AGENT_LIST )","title":"rdm_user_agent_value()"},{"location":"api/#pstock.utils.utils.parse_datetime","text":"Source code in pstock/utils/utils.py def parse_datetime ( value : tp . Union [ str , int , float , date , datetime ] ) -> pendulum . DateTime : errors : tp . List [ str ] = [] # try to parse a datetime string, int, bytes if not isinstance ( value , date ): try : return pendulum . instance ( parse_datetime_pydantic ( value )) except ( DateTimeError , TypeError ) as error : errors . append ( str ( error )) # if not above, maybe try to parse a date string, int, bytes object. try : _date = parse_date_pydantic ( value ) return pendulum . datetime ( _date . year , _date . month , _date . day ) except DateError as error : errors . append ( str ( error )) raise ValueError ( f \"Couldn't parse to datetime: { value } : { ', ' . join ( errors ) } \" )","title":"parse_datetime()"},{"location":"api/#pstock.utils.utils.parse_duration","text":"Source code in pstock/utils/utils.py def parse_duration ( value : tp . Union [ str , int , float , timedelta ]) -> pendulum . Duration : if isinstance ( value , timedelta ): return pendulum . duration ( seconds = value . total_seconds ()) try : return pendulum . duration ( seconds = parse_duration_pydantic ( value ) . total_seconds ()) except DurationError as error : assert isinstance ( value , str ), str ( error ) if value . lower () == \"mtd\" : return pendulum . duration ( months = 1 ) if value . lower () == \"ytd\" : return pendulum . duration ( years = 1 ) kwargs : tp . Dict [ str , float ] = {} for match in re . finditer ( _UNITS_REGEX , value , flags = re . I ): unit = match . group ( \"unit\" ) . lower () val = match . group ( \"val\" ) if unit not in _UNITS : raise DurationError () name , _type = _UNITS [ unit ] if name in kwargs : kwargs [ name ] += _type ( val ) else : kwargs [ name ] = _type ( val ) if not kwargs : raise DurationError () return pendulum . duration ( ** kwargs )","title":"parse_duration()"},{"location":"api/#pstock.utils.utils.httpx_client_manager","text":"Source code in pstock/utils/utils.py @asynccontextmanager async def httpx_client_manager ( client : tp . Optional [ httpx . AsyncClient ] = None , ) -> tp . AsyncGenerator [ httpx . AsyncClient , None ]: _close = False if client is None : _close = True client = httpx . AsyncClient () try : yield client finally : if _close : await client . aclose ()","title":"httpx_client_manager()"},{"location":"api/#pstock.asset","text":"","title":"asset"},{"location":"api/#pstock.asset.Asset","text":"Source code in pstock/asset.py class Asset ( QuoteSummary ): symbol : str name : str asset_type : tp . Literal [ \"EQUITY\" , \"CURRENCY\" , \"CRYPTOCURRENCY\" , \"ETF\" , \"FUTURE\" , \"INDEX\" ] currency : str latest_price : float = np . nan sector : tp . Optional [ str ] industry : tp . Optional [ str ] earnings : Earnings = Field ( repr = False ) trends : Trends = Field ( repr = False ) income_statement : tp . Optional [ IncomeStatements ] = Field ( repr = False ) @validator ( \"symbol\" ) def symbol_upper ( cls , symbol : str ) -> str : return symbol . upper () @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: data = get_asset_data_from_quote ( quote ) earnings = Earnings . process_quote ( quote ) trends = Trends . process_quote ( quote ) return { ** data , \"earnings\" : earnings , \"trends\" : trends } @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: income_statement = IncomeStatements . process_financials_quote ( financials_quote ) return { \"income_statement\" : income_statement }","title":"Asset"},{"location":"api/#pstock.asset.Asset.symbol","text":"","title":"symbol"},{"location":"api/#pstock.asset.Asset.name","text":"","title":"name"},{"location":"api/#pstock.asset.Asset.asset_type","text":"","title":"asset_type"},{"location":"api/#pstock.asset.Asset.currency","text":"","title":"currency"},{"location":"api/#pstock.asset.Asset.latest_price","text":"","title":"latest_price"},{"location":"api/#pstock.asset.Asset.sector","text":"","title":"sector"},{"location":"api/#pstock.asset.Asset.industry","text":"","title":"industry"},{"location":"api/#pstock.asset.Asset.earnings","text":"","title":"earnings"},{"location":"api/#pstock.asset.Asset.trends","text":"","title":"trends"},{"location":"api/#pstock.asset.Asset.income_statement","text":"","title":"income_statement"},{"location":"api/#pstock.asset.Asset.symbol_upper","text":"Source code in pstock/asset.py @validator ( \"symbol\" ) def symbol_upper ( cls , symbol : str ) -> str : return symbol . upper ()","title":"symbol_upper()"},{"location":"api/#pstock.asset.Asset.process_quote","text":"Source code in pstock/asset.py @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: data = get_asset_data_from_quote ( quote ) earnings = Earnings . process_quote ( quote ) trends = Trends . process_quote ( quote ) return { ** data , \"earnings\" : earnings , \"trends\" : trends }","title":"process_quote()"},{"location":"api/#pstock.asset.Asset.process_financials_quote","text":"Source code in pstock/asset.py @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: income_statement = IncomeStatements . process_financials_quote ( financials_quote ) return { \"income_statement\" : income_statement }","title":"process_financials_quote()"},{"location":"api/#pstock.asset.Assets","text":"Source code in pstock/asset.py class Assets ( BaseModelSequence [ Asset ]): __root__ : tp . List [ Asset ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () df [ \"earnings\" ] = df [ \"earnings\" ] . apply ( lambda v : None if len ( v ) == 0 else v ) df [ \"trends\" ] = df [ \"trends\" ] . apply ( lambda v : None if len ( v ) == 0 else v ) return df . set_index ( \"symbol\" ) . sort_index () . dropna ( axis = 1 , how = \"all\" ) @classmethod async def get ( cls , symbols : tp . List [ str ], * , client : tp . Optional [ httpx . AsyncClient ] = None , ): async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_values = [ tg . soonify ( Asset . get )( symbol , client = _client ) for symbol in symbols ] return cls . parse_obj ([ soon . value for soon in soon_values ])","title":"Assets"},{"location":"api/#pstock.asset.Assets.gen_df","text":"Source code in pstock/asset.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () df [ \"earnings\" ] = df [ \"earnings\" ] . apply ( lambda v : None if len ( v ) == 0 else v ) df [ \"trends\" ] = df [ \"trends\" ] . apply ( lambda v : None if len ( v ) == 0 else v ) return df . set_index ( \"symbol\" ) . sort_index () . dropna ( axis = 1 , how = \"all\" )","title":"gen_df()"},{"location":"api/#pstock.asset.Assets.get","text":"Source code in pstock/asset.py @classmethod async def get ( cls , symbols : tp . List [ str ], * , client : tp . Optional [ httpx . AsyncClient ] = None , ): async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_values = [ tg . soonify ( Asset . get )( symbol , client = _client ) for symbol in symbols ] return cls . parse_obj ([ soon . value for soon in soon_values ])","title":"get()"},{"location":"api/#pstock.bar","text":"","title":"bar"},{"location":"api/#pstock.bar.EventParam","text":"","title":"EventParam"},{"location":"api/#pstock.bar.IntervalParam","text":"","title":"IntervalParam"},{"location":"api/#pstock.bar.PeriodParam","text":"","title":"PeriodParam"},{"location":"api/#pstock.bar.Bar","text":"Source code in pstock/bar.py class Bar ( BaseModel ): date : datetime open : float high : float low : float close : float adj_close : float volume : float interval : timedelta","title":"Bar"},{"location":"api/#pstock.bar.Bar.date","text":"","title":"date"},{"location":"api/#pstock.bar.Bar.open","text":"","title":"open"},{"location":"api/#pstock.bar.Bar.high","text":"","title":"high"},{"location":"api/#pstock.bar.Bar.low","text":"","title":"low"},{"location":"api/#pstock.bar.Bar.close","text":"","title":"close"},{"location":"api/#pstock.bar.Bar.adj_close","text":"","title":"adj_close"},{"location":"api/#pstock.bar.Bar.volume","text":"","title":"volume"},{"location":"api/#pstock.bar.Bar.interval","text":"","title":"interval"},{"location":"api/#pstock.bar.Bars","text":"Source code in pstock/bar.py class Bars ( BaseModelSequence [ Bar ], _BarMixin ): __root__ : tp . List [ Bar ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . dropna ( how = \"all\" , subset = [ \"open\" , \"high\" , \"low\" , \"close\" , \"adj_close\" , \"volume\" ], ) if df [ \"interval\" ][ 0 ] >= timedelta ( days = 1 ): df [ \"date\" ] = pd . to_datetime ( pd . to_datetime ( df [ \"date\" ]) . dt . date ) df = df . set_index ( \"date\" ) . sort_index () return df @classmethod def load ( cls , * , response : tp . Union [ ReadableResponse , str , bytes , dict ], ) -> Bars : if isinstance ( response , dict ): data = response elif isinstance ( response , ( str , bytes )): data = json . loads ( response ) else : data = json . loads ( response . read ()) return cls . parse_obj ( get_ohlc_from_chart ( data )) @classmethod async def get ( cls , symbol : str , * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = \"div,splits\" , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None , ): url = cls . base_uri ( symbol ) params = cls . params ( interval = interval , period = period , start = start , end = end , events = events , include_prepost = include_prepost , ) async with httpx_client_manager ( client = client ) as _client : response = await _client . get ( url , params = params ) return cls . load ( response = response )","title":"Bars"},{"location":"api/#pstock.bar.Bars.gen_df","text":"Source code in pstock/bar.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . dropna ( how = \"all\" , subset = [ \"open\" , \"high\" , \"low\" , \"close\" , \"adj_close\" , \"volume\" ], ) if df [ \"interval\" ][ 0 ] >= timedelta ( days = 1 ): df [ \"date\" ] = pd . to_datetime ( pd . to_datetime ( df [ \"date\" ]) . dt . date ) df = df . set_index ( \"date\" ) . sort_index () return df","title":"gen_df()"},{"location":"api/#pstock.bar.Bars.load","text":"Source code in pstock/bar.py @classmethod def load ( cls , * , response : tp . Union [ ReadableResponse , str , bytes , dict ], ) -> Bars : if isinstance ( response , dict ): data = response elif isinstance ( response , ( str , bytes )): data = json . loads ( response ) else : data = json . loads ( response . read ()) return cls . parse_obj ( get_ohlc_from_chart ( data ))","title":"load()"},{"location":"api/#pstock.bar.Bars.get","text":"Source code in pstock/bar.py @classmethod async def get ( cls , symbol : str , * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = \"div,splits\" , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None , ): url = cls . base_uri ( symbol ) params = cls . params ( interval = interval , period = period , start = start , end = end , events = events , include_prepost = include_prepost , ) async with httpx_client_manager ( client = client ) as _client : response = await _client . get ( url , params = params ) return cls . load ( response = response )","title":"get()"},{"location":"api/#pstock.bar.BarsMulti","text":"Source code in pstock/bar.py class BarsMulti ( BaseModelMapping [ Bars ], _BarMixin ): __root__ : tp . Dict [ str , Bars ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () return df . sort_index () @classmethod async def get ( cls , symbols : tp . List [ str ], * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = \"div,splits\" , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None , ): async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_values = [ tg . soonify ( Bars . get )( symbol , interval = interval , period = period , start = start , end = end , include_prepost = include_prepost , events = events , client = _client , ) for symbol in symbols ] data = { symbol : soon_value . value for symbol , soon_value in zip ( symbols , soon_values ) } return cls . parse_obj ( data )","title":"BarsMulti"},{"location":"api/#pstock.bar.BarsMulti.gen_df","text":"Source code in pstock/bar.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () return df . sort_index ()","title":"gen_df()"},{"location":"api/#pstock.bar.BarsMulti.get","text":"Source code in pstock/bar.py @classmethod async def get ( cls , symbols : tp . List [ str ], * , interval : tp . Optional [ IntervalParam ] = None , period : tp . Optional [ PeriodParam ] = None , start : tp . Optional [ Timestamp ] = None , end : tp . Optional [ Timestamp ] = None , events : EventParam = \"div,splits\" , include_prepost : bool = False , client : tp . Optional [ httpx . AsyncClient ] = None , ): async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_values = [ tg . soonify ( Bars . get )( symbol , interval = interval , period = period , start = start , end = end , include_prepost = include_prepost , events = events , client = _client , ) for symbol in symbols ] data = { symbol : soon_value . value for symbol , soon_value in zip ( symbols , soon_values ) } return cls . parse_obj ( data )","title":"get()"},{"location":"api/#pstock.base","text":"","title":"base"},{"location":"api/#pstock.base.T","text":"","title":"T"},{"location":"api/#pstock.base.U","text":"","title":"U"},{"location":"api/#pstock.base.BaseModel","text":"Source code in pstock/base.py class BaseModel ( _BaseModel ): _created_at : datetime = PrivateAttr ( default_factory = pendulum . now ) @property def created_at ( self ) -> datetime : return self . _created_at","title":"BaseModel"},{"location":"api/#pstock.base.BaseModel.created_at","text":"","title":"created_at"},{"location":"api/#pstock.base.BaseModelDf","text":"Source code in pstock/base.py class BaseModelDf ( BaseModel , ABC ): _df : tp . Optional [ pd . DataFrame ] = PrivateAttr ( default = None ) @abstractmethod def gen_df ( self ) -> pd . DataFrame : ... @property def df ( self ) -> pd . DataFrame : if self . _df is None : self . _df = self . gen_df () return self . _df","title":"BaseModelDf"},{"location":"api/#pstock.base.BaseModelDf.df","text":"","title":"df"},{"location":"api/#pstock.base.BaseModelDf.gen_df","text":"Source code in pstock/base.py @abstractmethod def gen_df ( self ) -> pd . DataFrame : ...","title":"gen_df()"},{"location":"api/#pstock.base.BaseModelSequence","text":"Source code in pstock/base.py class BaseModelSequence ( tp . Generic [ T ], BaseModelDf ): __root__ : tp . Sequence [ T ] @tp . overload def __getitem__ ( self , index : int ) -> T : \"\"\"Get single item from __root__ by idx.\"\"\" @tp . overload def __getitem__ ( self , index : slice ) -> tp . Sequence [ T ]: \"\"\"Get slice of items from __root__ by idx.\"\"\" def __getitem__ ( self , index ): return self . __root__ [ index ] def __len__ ( self ) -> int : return len ( self . __root__ ) def __iter__ ( self ) -> tp . Iterator [ T ]: # type: ignore return iter ( self . __root__ ) def gen_df ( self ) -> pd . DataFrame : return pd . DataFrame . from_dict ( self . dict () . get ( \"__root__\" ), orient = \"columns\" )","title":"BaseModelSequence"},{"location":"api/#pstock.base.BaseModelSequence.__root__","text":"","title":"__root__"},{"location":"api/#pstock.base.BaseModelSequence.gen_df","text":"Source code in pstock/base.py def gen_df ( self ) -> pd . DataFrame : return pd . DataFrame . from_dict ( self . dict () . get ( \"__root__\" ), orient = \"columns\" )","title":"gen_df()"},{"location":"api/#pstock.base.BaseModelMapping","text":"Source code in pstock/base.py class BaseModelMapping ( tp . Generic [ U ], BaseModelDf ): __root__ : tp . Mapping [ str , U ] def __getitem__ ( self , index : str ) -> U : return self . __root__ [ index ] def __len__ ( self ) -> int : return len ( self . __root__ ) def __iter__ ( self ) -> tp . Iterator [ str ]: # type: ignore return iter ( self . __root__ ) def gen_df ( self ) -> pd . DataFrame : keys , dfs = zip ( * [( key , value . df ) for key , value in self . __root__ . items ()]) return pd . concat ( dfs , axis = 1 , keys = keys )","title":"BaseModelMapping"},{"location":"api/#pstock.base.BaseModelMapping.__root__","text":"","title":"__root__"},{"location":"api/#pstock.base.BaseModelMapping.gen_df","text":"Source code in pstock/base.py def gen_df ( self ) -> pd . DataFrame : keys , dfs = zip ( * [( key , value . df ) for key , value in self . __root__ . items ()]) return pd . concat ( dfs , axis = 1 , keys = keys )","title":"gen_df()"},{"location":"api/#pstock.earnings","text":"","title":"earnings"},{"location":"api/#pstock.earnings.Earning","text":"Source code in pstock/earnings.py class Earning ( BaseModel ): quarter : str estimate : float actual : float status : tp . Literal [ None , \"Beat\" , \"Missed\" ] = None revenue : float earnings : float @validator ( \"status\" , always = True ) def set_status ( cls , value : tp . Any , values : tp . Dict [ str , tp . Any ] ) -> tp . Literal [ None , \"Beat\" , \"Missed\" ]: if value is not None : return value estimate = values . get ( \"estimate\" ) actual = values . get ( \"actual\" ) if actual is None or np . isnan ( actual ) or estimate is None or np . isnan ( estimate ): return None return \"Beat\" if actual >= estimate else \"Missed\"","title":"Earning"},{"location":"api/#pstock.earnings.Earning.quarter","text":"","title":"quarter"},{"location":"api/#pstock.earnings.Earning.estimate","text":"","title":"estimate"},{"location":"api/#pstock.earnings.Earning.actual","text":"","title":"actual"},{"location":"api/#pstock.earnings.Earning.status","text":"","title":"status"},{"location":"api/#pstock.earnings.Earning.revenue","text":"","title":"revenue"},{"location":"api/#pstock.earnings.Earning.earnings","text":"","title":"earnings"},{"location":"api/#pstock.earnings.Earning.set_status","text":"Source code in pstock/earnings.py @validator ( \"status\" , always = True ) def set_status ( cls , value : tp . Any , values : tp . Dict [ str , tp . Any ] ) -> tp . Literal [ None , \"Beat\" , \"Missed\" ]: if value is not None : return value estimate = values . get ( \"estimate\" ) actual = values . get ( \"actual\" ) if actual is None or np . isnan ( actual ) or estimate is None or np . isnan ( estimate ): return None return \"Beat\" if actual >= estimate else \"Missed\"","title":"set_status()"},{"location":"api/#pstock.earnings.Earnings","text":"Source code in pstock/earnings.py class Earnings ( BaseModelSequence [ Earning ], QuoteSummary ): __root__ : tp . List [ Earning ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"quarter\" ) . sort_index ( key = pd . to_datetime ) return df @validator ( \"__root__\" ) def sort_earnings ( cls , value : tp . List [ Earning ]) -> tp . List [ Earning ]: if not value : return value return sorted ( value , key = lambda earning : pd . to_datetime ( earning . quarter )) @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_earnings_data_from_quote ( quote )}","title":"Earnings"},{"location":"api/#pstock.earnings.Earnings.gen_df","text":"Source code in pstock/earnings.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"quarter\" ) . sort_index ( key = pd . to_datetime ) return df","title":"gen_df()"},{"location":"api/#pstock.earnings.Earnings.sort_earnings","text":"Source code in pstock/earnings.py @validator ( \"__root__\" ) def sort_earnings ( cls , value : tp . List [ Earning ]) -> tp . List [ Earning ]: if not value : return value return sorted ( value , key = lambda earning : pd . to_datetime ( earning . quarter ))","title":"sort_earnings()"},{"location":"api/#pstock.earnings.Earnings.process_quote","text":"Source code in pstock/earnings.py @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_earnings_data_from_quote ( quote )}","title":"process_quote()"},{"location":"api/#pstock.income_statement","text":"","title":"income_statement"},{"location":"api/#pstock.income_statement.IncomeStatement","text":"Source code in pstock/income_statement.py class IncomeStatement ( BaseModel ): date : date ebit : float total_revenue : float gross_profit : float","title":"IncomeStatement"},{"location":"api/#pstock.income_statement.IncomeStatement.date","text":"","title":"date"},{"location":"api/#pstock.income_statement.IncomeStatement.ebit","text":"","title":"ebit"},{"location":"api/#pstock.income_statement.IncomeStatement.total_revenue","text":"","title":"total_revenue"},{"location":"api/#pstock.income_statement.IncomeStatement.gross_profit","text":"","title":"gross_profit"},{"location":"api/#pstock.income_statement.BaseIncomeStatements","text":"Source code in pstock/income_statement.py class BaseIncomeStatements ( BaseModelSequence [ IncomeStatement ], QuoteSummary ): __root__ : tp . List [ IncomeStatement ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df","title":"BaseIncomeStatements"},{"location":"api/#pstock.income_statement.BaseIncomeStatements.gen_df","text":"Source code in pstock/income_statement.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df","title":"gen_df()"},{"location":"api/#pstock.income_statement.IncomeStatements","text":"Source code in pstock/income_statement.py class IncomeStatements ( BaseIncomeStatements ): @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_income_statement_data_from_financials_quote ( financials_quote , key = \"incomeStatementHistory\" ) } @property def revenue_compound_annual_growth_rate ( self ) -> float : \"\"\"Revenue CAGR. https://www.investopedia.com/terms/c/cagr.asp Returns: float: Revenue CAGR based \"\"\" latest_revenue = self . df . max ()[ \"total_revenue\" ] earliest_revenue = self . df . min ()[ \"total_revenue\" ] num_years = len ( self . df ) - 1 return ( latest_revenue / earliest_revenue ) ** ( 1 / num_years ) - 1","title":"IncomeStatements"},{"location":"api/#pstock.income_statement.IncomeStatements.revenue_compound_annual_growth_rate","text":"Revenue CAGR. https://www.investopedia.com/terms/c/cagr.asp Returns: Type Description float Revenue CAGR based","title":"revenue_compound_annual_growth_rate"},{"location":"api/#pstock.income_statement.IncomeStatements.process_financials_quote","text":"Source code in pstock/income_statement.py @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_income_statement_data_from_financials_quote ( financials_quote , key = \"incomeStatementHistory\" ) }","title":"process_financials_quote()"},{"location":"api/#pstock.income_statement.QuarterlyIncomeStatements","text":"Source code in pstock/income_statement.py class QuarterlyIncomeStatements ( BaseIncomeStatements ): @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_income_statement_data_from_financials_quote ( financials_quote , key = \"incomeStatementHistoryQuarterly\" ) } @property def revenue_compound_annual_growth_rate ( self ) -> float : raise NotImplementedError ()","title":"QuarterlyIncomeStatements"},{"location":"api/#pstock.income_statement.QuarterlyIncomeStatements.revenue_compound_annual_growth_rate","text":"","title":"revenue_compound_annual_growth_rate"},{"location":"api/#pstock.income_statement.QuarterlyIncomeStatements.process_financials_quote","text":"Source code in pstock/income_statement.py @classmethod def process_financials_quote ( cls , financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_income_statement_data_from_financials_quote ( financials_quote , key = \"incomeStatementHistoryQuarterly\" ) }","title":"process_financials_quote()"},{"location":"api/#pstock.news","text":"","title":"news"},{"location":"api/#pstock.news.Publication","text":"Source code in pstock/news.py class Publication ( BaseModel ): date : datetime . datetime title : str url : str summary : tp . Optional [ str ]","title":"Publication"},{"location":"api/#pstock.news.Publication.date","text":"","title":"date"},{"location":"api/#pstock.news.Publication.title","text":"","title":"title"},{"location":"api/#pstock.news.Publication.url","text":"","title":"url"},{"location":"api/#pstock.news.Publication.summary","text":"","title":"summary"},{"location":"api/#pstock.news.News","text":"Source code in pstock/news.py class News ( BaseModelSequence ): __root__ : tp . List [ Publication ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df @staticmethod def base_uri () -> str : return \"https://feeds.finance.yahoo.com/rss/2.0/headline\" @staticmethod def params ( symbol : str ) -> tp . Dict [ str , str ]: return { \"s\" : symbol . upper (), \"region\" : \"US\" , \"lang\" : \"en-US\" } @classmethod def uri ( cls , symbol : str ) -> str : return f \" { cls . base_uri () } ? { urlencode ( cls . params ( symbol )) } \" @classmethod def load ( cls , * , symbol : tp . Optional [ str ] = None , response : tp . Union [ None , str , bytes , ReadableResponse ] = None , ) -> News : if symbol is not None and response is None : # feedparser can take a uri as input, and get data over http response = cls . uri ( symbol ) print ( response ) if response is None : raise ValueError ( \"Please provide either a symbol or or a readeable response.\" ) feed = feedparser . parse ( response ) return cls . parse_obj ( [ { ** entry , \"date\" : time . mktime ( entry [ \"published_parsed\" ]), \"url\" : entry [ \"link\" ], } for entry in feed . entries ] ) @classmethod async def get ( cls , symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None , ) -> News : async with httpx_client_manager ( client = client ) as _client : response = await _client . get ( cls . base_uri (), params = cls . params ( symbol )) return cls . load ( response = response )","title":"News"},{"location":"api/#pstock.news.News.gen_df","text":"Source code in pstock/news.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df","title":"gen_df()"},{"location":"api/#pstock.news.News.base_uri","text":"Source code in pstock/news.py @staticmethod def base_uri () -> str : return \"https://feeds.finance.yahoo.com/rss/2.0/headline\"","title":"base_uri()"},{"location":"api/#pstock.news.News.params","text":"Source code in pstock/news.py @staticmethod def params ( symbol : str ) -> tp . Dict [ str , str ]: return { \"s\" : symbol . upper (), \"region\" : \"US\" , \"lang\" : \"en-US\" }","title":"params()"},{"location":"api/#pstock.news.News.uri","text":"Source code in pstock/news.py @classmethod def uri ( cls , symbol : str ) -> str : return f \" { cls . base_uri () } ? { urlencode ( cls . params ( symbol )) } \"","title":"uri()"},{"location":"api/#pstock.news.News.load","text":"Source code in pstock/news.py @classmethod def load ( cls , * , symbol : tp . Optional [ str ] = None , response : tp . Union [ None , str , bytes , ReadableResponse ] = None , ) -> News : if symbol is not None and response is None : # feedparser can take a uri as input, and get data over http response = cls . uri ( symbol ) print ( response ) if response is None : raise ValueError ( \"Please provide either a symbol or or a readeable response.\" ) feed = feedparser . parse ( response ) return cls . parse_obj ( [ { ** entry , \"date\" : time . mktime ( entry [ \"published_parsed\" ]), \"url\" : entry [ \"link\" ], } for entry in feed . entries ] )","title":"load()"},{"location":"api/#pstock.news.News.get","text":"Source code in pstock/news.py @classmethod async def get ( cls , symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None , ) -> News : async with httpx_client_manager ( client = client ) as _client : response = await _client . get ( cls . base_uri (), params = cls . params ( symbol )) return cls . load ( response = response )","title":"get()"},{"location":"api/#pstock.quote","text":"","title":"quote"},{"location":"api/#pstock.quote.T","text":"","title":"T"},{"location":"api/#pstock.quote.QuoteSummary","text":"Source code in pstock/quote.py class QuoteSummary ( BaseModel ): @staticmethod def uri ( symbol : str ) -> str : return f \"https://finance.yahoo.com/quote/ { symbol . upper () } \" @staticmethod def financials_uri ( symbol : str ) -> str : return ( f \"https://finance.yahoo.com/quote/ { symbol . upper () } /\" f \"financials?p= { symbol . upper () } \" ) @staticmethod def parse_quote ( response : tp . Union [ ReadableResponse , str , bytes ] ) -> tp . Dict [ str , tp . Any ]: content = response if isinstance ( response , ( str , bytes )) else response . read () soup = BeautifulSoup ( content , \"html.parser\" ) script = soup . find ( \"script\" , text = re . compile ( r \"root.App.main\" )) if script is None : return {} match = re . search ( r \"root.App.main\\s+=\\s+(\\{.*\\})\" , script . text ) if match is None : return {} data : tp . Dict [ str , tp . Any ] = json . loads ( match . group ( 1 )) return ( data . get ( \"context\" , {}) . get ( \"dispatcher\" , {}) . get ( \"stores\" , {}) . get ( \"QuoteSummaryStore\" , {}) ) @classmethod def process_quote ( cls : tp . Type [ T ], quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return {} @classmethod def process_financials_quote ( cls : tp . Type [ T ], financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return {} @classmethod def load ( cls : tp . Type [ T ], * , response : tp . Union [ ReadableResponse , str , bytes , None ] = None , financials_response : tp . Union [ ReadableResponse , str , bytes , None ] = None , ) -> T : data = {} _quote = None _financials_quote = None if response is not None : _quote = cls . parse_quote ( response ) if _quote : data . update ( cls . process_quote ( _quote )) if financials_response is not None : _financials_quote = cls . parse_quote ( financials_response ) if _financials_quote : data . update ( cls . process_financials_quote ( _financials_quote )) return cls ( ** data ) @classmethod async def get ( cls : tp . Type [ T ], symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None , ) -> T : async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_quote = tg . soonify ( _client . get )( cls . uri ( symbol ), headers = { \"user-agent\" : rdm_user_agent_value ()} ) soon_financials = tg . soonify ( _client . get )( cls . financials_uri ( symbol ), headers = { \"user-agent\" : rdm_user_agent_value ()}, ) return cls . load ( response = soon_quote . value , financials_response = soon_financials . value )","title":"QuoteSummary"},{"location":"api/#pstock.quote.QuoteSummary.uri","text":"Source code in pstock/quote.py @staticmethod def uri ( symbol : str ) -> str : return f \"https://finance.yahoo.com/quote/ { symbol . upper () } \"","title":"uri()"},{"location":"api/#pstock.quote.QuoteSummary.financials_uri","text":"Source code in pstock/quote.py @staticmethod def financials_uri ( symbol : str ) -> str : return ( f \"https://finance.yahoo.com/quote/ { symbol . upper () } /\" f \"financials?p= { symbol . upper () } \" )","title":"financials_uri()"},{"location":"api/#pstock.quote.QuoteSummary.parse_quote","text":"Source code in pstock/quote.py @staticmethod def parse_quote ( response : tp . Union [ ReadableResponse , str , bytes ] ) -> tp . Dict [ str , tp . Any ]: content = response if isinstance ( response , ( str , bytes )) else response . read () soup = BeautifulSoup ( content , \"html.parser\" ) script = soup . find ( \"script\" , text = re . compile ( r \"root.App.main\" )) if script is None : return {} match = re . search ( r \"root.App.main\\s+=\\s+(\\{.*\\})\" , script . text ) if match is None : return {} data : tp . Dict [ str , tp . Any ] = json . loads ( match . group ( 1 )) return ( data . get ( \"context\" , {}) . get ( \"dispatcher\" , {}) . get ( \"stores\" , {}) . get ( \"QuoteSummaryStore\" , {}) )","title":"parse_quote()"},{"location":"api/#pstock.quote.QuoteSummary.process_quote","text":"Source code in pstock/quote.py @classmethod def process_quote ( cls : tp . Type [ T ], quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return {}","title":"process_quote()"},{"location":"api/#pstock.quote.QuoteSummary.process_financials_quote","text":"Source code in pstock/quote.py @classmethod def process_financials_quote ( cls : tp . Type [ T ], financials_quote : tp . Dict [ str , tp . Any ] ) -> tp . Dict [ str , tp . Any ]: return {}","title":"process_financials_quote()"},{"location":"api/#pstock.quote.QuoteSummary.load","text":"Source code in pstock/quote.py @classmethod def load ( cls : tp . Type [ T ], * , response : tp . Union [ ReadableResponse , str , bytes , None ] = None , financials_response : tp . Union [ ReadableResponse , str , bytes , None ] = None , ) -> T : data = {} _quote = None _financials_quote = None if response is not None : _quote = cls . parse_quote ( response ) if _quote : data . update ( cls . process_quote ( _quote )) if financials_response is not None : _financials_quote = cls . parse_quote ( financials_response ) if _financials_quote : data . update ( cls . process_financials_quote ( _financials_quote )) return cls ( ** data )","title":"load()"},{"location":"api/#pstock.quote.QuoteSummary.get","text":"Source code in pstock/quote.py @classmethod async def get ( cls : tp . Type [ T ], symbol : str , * , client : tp . Optional [ httpx . AsyncClient ] = None , ) -> T : async with httpx_client_manager ( client = client ) as _client : async with asyncer . create_task_group () as tg : soon_quote = tg . soonify ( _client . get )( cls . uri ( symbol ), headers = { \"user-agent\" : rdm_user_agent_value ()} ) soon_financials = tg . soonify ( _client . get )( cls . financials_uri ( symbol ), headers = { \"user-agent\" : rdm_user_agent_value ()}, ) return cls . load ( response = soon_quote . value , financials_response = soon_financials . value )","title":"get()"},{"location":"api/#pstock.trend","text":"","title":"trend"},{"location":"api/#pstock.trend.Trend","text":"Source code in pstock/trend.py class Trend ( BaseModel ): date : datetime . date strong_buy : int = 0 buy : int = 0 hold : int = 0 sell : int = 0 strong_sell : int = 0 score : tp . Optional [ float ] = None recomendation : tp . Literal [ None , \"STRONG_BUY\" , \"BUY\" , \"HOLD\" , \"SELL\" , \"STRONG_SELL\" ] = None @validator ( \"score\" , always = True ) def compute_score ( cls , value : tp . Optional [ float ], values : tp . Dict [ str , tp . Any ] ) -> float : if value is not None : return value numerator = ( values [ \"strong_buy\" ] + values [ \"buy\" ] * 2 + values [ \"hold\" ] * 3 + values [ \"sell\" ] * 4 + values [ \"strong_sell\" ] * 5 ) denominator = ( values [ \"strong_buy\" ] + values [ \"buy\" ] + values [ \"hold\" ] + values [ \"sell\" ] + values [ \"strong_sell\" ] ) if denominator == 0 : return np . nan return round ( numerator / denominator , 2 ) @validator ( \"recomendation\" , always = True ) def compute_recomendation ( cls , value : tp . Optional [ float ], values : tp . Dict [ str , tp . Any ] ): if value is not None : return value score = values [ \"score\" ] if np . isnan ( score ): return \"UNKNOWN\" elif score >= 4.5 : return \"STRONG_SELL\" elif score >= 3.5 : return \"SELL\" elif score >= 2.5 : return \"HOLD\" elif score >= 1.5 : return \"BUY\" else : return \"STRONG_BUY\"","title":"Trend"},{"location":"api/#pstock.trend.Trend.date","text":"","title":"date"},{"location":"api/#pstock.trend.Trend.strong_buy","text":"","title":"strong_buy"},{"location":"api/#pstock.trend.Trend.buy","text":"","title":"buy"},{"location":"api/#pstock.trend.Trend.hold","text":"","title":"hold"},{"location":"api/#pstock.trend.Trend.sell","text":"","title":"sell"},{"location":"api/#pstock.trend.Trend.strong_sell","text":"","title":"strong_sell"},{"location":"api/#pstock.trend.Trend.score","text":"","title":"score"},{"location":"api/#pstock.trend.Trend.recomendation","text":"","title":"recomendation"},{"location":"api/#pstock.trend.Trend.compute_score","text":"Source code in pstock/trend.py @validator ( \"score\" , always = True ) def compute_score ( cls , value : tp . Optional [ float ], values : tp . Dict [ str , tp . Any ] ) -> float : if value is not None : return value numerator = ( values [ \"strong_buy\" ] + values [ \"buy\" ] * 2 + values [ \"hold\" ] * 3 + values [ \"sell\" ] * 4 + values [ \"strong_sell\" ] * 5 ) denominator = ( values [ \"strong_buy\" ] + values [ \"buy\" ] + values [ \"hold\" ] + values [ \"sell\" ] + values [ \"strong_sell\" ] ) if denominator == 0 : return np . nan return round ( numerator / denominator , 2 )","title":"compute_score()"},{"location":"api/#pstock.trend.Trend.compute_recomendation","text":"Source code in pstock/trend.py @validator ( \"recomendation\" , always = True ) def compute_recomendation ( cls , value : tp . Optional [ float ], values : tp . Dict [ str , tp . Any ] ): if value is not None : return value score = values [ \"score\" ] if np . isnan ( score ): return \"UNKNOWN\" elif score >= 4.5 : return \"STRONG_SELL\" elif score >= 3.5 : return \"SELL\" elif score >= 2.5 : return \"HOLD\" elif score >= 1.5 : return \"BUY\" else : return \"STRONG_BUY\"","title":"compute_recomendation()"},{"location":"api/#pstock.trend.Trends","text":"Source code in pstock/trend.py class Trends ( BaseModelSequence [ Trend ], QuoteSummary ): __root__ : tp . List [ Trend ] def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df @validator ( \"__root__\" ) def sort_trends ( cls , value : tp . List [ Trend ]) -> tp . List [ Trend ]: if not value : return value return sorted ( value , key = lambda trend : pd . to_datetime ( trend . date )) @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_trends_data_from_quote ( quote )}","title":"Trends"},{"location":"api/#pstock.trend.Trends.gen_df","text":"Source code in pstock/trend.py def gen_df ( self ) -> pd . DataFrame : df = super () . gen_df () if not df . empty : df = df . set_index ( \"date\" ) . sort_index () return df","title":"gen_df()"},{"location":"api/#pstock.trend.Trends.sort_trends","text":"Source code in pstock/trend.py @validator ( \"__root__\" ) def sort_trends ( cls , value : tp . List [ Trend ]) -> tp . List [ Trend ]: if not value : return value return sorted ( value , key = lambda trend : pd . to_datetime ( trend . date ))","title":"sort_trends()"},{"location":"api/#pstock.trend.Trends.process_quote","text":"Source code in pstock/trend.py @classmethod def process_quote ( cls , quote : tp . Dict [ str , tp . Any ]) -> tp . Dict [ str , tp . Any ]: return { \"__root__\" : get_trends_data_from_quote ( quote )}","title":"process_quote()"},{"location":"api/#pstock.types","text":"","title":"types"},{"location":"api/#pstock.types.Timestamp","text":"Source code in pstock/types.py class Timestamp ( int ): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , value : tp . Union [ str , int , float , date , datetime ]) -> int : return parse_datetime ( value ) . int_timestamp","title":"Timestamp"},{"location":"api/#pstock.types.Timestamp.validate","text":"Source code in pstock/types.py @classmethod def validate ( cls , value : tp . Union [ str , int , float , date , datetime ]) -> int : return parse_datetime ( value ) . int_timestamp","title":"validate()"},{"location":"api/#pstock.types.ReadableResponse","text":"Source code in pstock/types.py class ReadableResponse ( tp . Protocol ): def read ( self ) -> tp . Union [ str , bytes ]: ...","title":"ReadableResponse"},{"location":"api/#pstock.types.ReadableResponse.read","text":"Source code in pstock/types.py def read ( self ) -> tp . Union [ str , bytes ]: ...","title":"read()"},{"location":"api/#pstock.types.ReadableResponse.__init__","text":"Source code in pstock/types.py def _no_init_or_replace_init ( self , * args , ** kwargs ): cls = type ( self ) if cls . _is_protocol : raise TypeError ( 'Protocols cannot be instantiated' ) # Already using a custom `__init__`. No need to calculate correct # `__init__` to call. This can lead to RecursionError. See bpo-45121. if cls . __init__ is not _no_init_or_replace_init : return # Initially, `__init__` of a protocol subclass is set to `_no_init_or_replace_init`. # The first instantiation of the subclass will call `_no_init_or_replace_init` which # searches for a proper new `__init__` in the MRO. The new `__init__` # replaces the subclass' old `__init__` (ie `_no_init_or_replace_init`). Subsequent # instantiation of the protocol subclass will thus use the new # `__init__` and no longer call `_no_init_or_replace_init`. for base in cls . __mro__ : init = base . __dict__ . get ( '__init__' , _no_init_or_replace_init ) if init is not _no_init_or_replace_init : cls . __init__ = init break else : # should not happen cls . __init__ = object . __init__ cls . __init__ ( self , * args , ** kwargs )","title":"__init__()"},{"location":"user-guide/","text":"User Guide Assets An Asset in pstock terms is any ticker symbol supported by yahoo-finance. If the asset exists in yahoo-finance, you should be able to get it's quote summary using pstock . import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset ) # symbol='TSLA' name='Tesla, Inc.' asset_type='EQUITY' currency='USD' latest_price=920.0 sector='Consumer Cyclical' industry='Auto Manufacturers' An Asset will always have a: symbol : The ticker symbol of the asset name : The long/short name of the asset (depending on which is found, the long name takes priority) asset_type : Type of the asset, can be one of: EQUITY , CURRENCY , CRYPTOCURRENCY , ETF , FUTURE , INDEX currency : Currency of the asset, USD for US stocks latest_price : Latest price of the asset known by yahoo-finance, takes into account the pre-post market prices. Can be numpy.nan if no proce data is found. Note: if an asset_type exists in yahoo-finance but is not one of the above, feel free to open an issue or PR. In the meantime you can subclass the Asset object and override the type of asset_type and add the missing asset type The other fields are optional and can be filled depending on the asset_type , currently there are only fields for the EQUITY (stocks) asset_type: sector industry [trends](#trends) [earnings](#earnings) [income_statement](#income-statement) In addition to getting data about a single Asset , there is also the possibily to query multiple assets at the same time using Assets . The main benefit is that it provides the ability to directly convert the resulting list of assets into a pandas dataframe. import asyncio from pstock import Asset assets = asyncio . run ( Assets . get ([ \"TSLA\" , \"AAPL\" , \"GME\" ])) print ( assets . df ) name asset_type currency ... earnings trends income_statement symbol ... AAPL Apple Inc . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 0.99 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 13, ' buy ':... [{' date ': 2021-09-25, ' ebit ': 108949000000.0, ... GME GameStop Corp . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 1.35 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 2, ' buy ': ... [{' date ': 2021-01-30, ' ebit ': -249300000.0, ' t ... TSLA Tesla , Inc . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 0.79 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 4, ' buy ': ... [{' date ': 2021-12-31, ' ebit ': 6523000000.0, ' t ... Note 1: Assets is also a pydantic model that will validate data that it pulls from yahoo-finance. Note 2: The generated pandas Dataframe is cached into a private ._df attribute and is computed only the first time it is accessed via the property .df . Note 3: Most if not all data objects in pstock have a .df property, and it's the recommended way to view and manipulate data when possible. Note 4: Assets , Bars , Earnings , News , ... can also be iterated over and support indexing and behave like a typing.List[Asset] , typing.List[Bar] , ... Trends There are 2 ways to get the trends of a symbol. via Asset : import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset . trends . df ) strong_buy buy hold sell strong_sell score recomendation date 2021 - 11 - 17 4 4 8 6 0 2.73 HOLD 2021 - 12 - 17 11 6 13 6 0 2.39 BUY 2022 - 01 - 16 11 6 13 6 0 2.39 BUY 2022 - 02 - 15 4 4 8 6 0 2.73 HOLD Directly via Trends import asyncio from pstock import Trends trends = asyncio . run ( Trends . get ( \"TSLA\" )) print ( trends . df ) strong_buy buy hold sell strong_sell score recomendation date 2021 - 11 - 17 4 4 8 6 0 2.73 HOLD 2021 - 12 - 17 11 6 13 6 0 2.39 BUY 2022 - 01 - 16 11 6 13 6 0 2.39 BUY 2022 - 02 - 15 4 4 8 6 0 2.73 HOLD Earnings There are 2 ways to get the earnings of a symbol. via Asset : import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset . earnings . df ) estimate actual status revenue earnings quarter 1 Q2021 0.79 0.93 Beat 1.038900e+10 4.380000e+08 2 Q2021 0.98 1.45 Beat 1.195800e+10 1.142000e+09 3 Q2021 1.59 1.86 Beat 1.375700e+10 1.618000e+09 4 Q2021 2.37 2.54 Beat 1.771900e+10 2.321000e+09 1 Q2022 2.25 NaN None NaN NaN Directly via Earnings import asyncio from pstock import Earnings earnings = asyncio . run ( Earnings . get ( \"TSLA\" )) print ( earnings . df ) estimate actual status revenue earnings quarter 1 Q2021 0.79 0.93 Beat 1.038900e+10 4.380000e+08 2 Q2021 0.98 1.45 Beat 1.195800e+10 1.142000e+09 3 Q2021 1.59 1.86 Beat 1.375700e+10 1.618000e+09 4 Q2021 2.37 2.54 Beat 1.771900e+10 2.321000e+09 1 Q2022 2.25 NaN None NaN NaN Note: The last earning have NaN / None values since we only have analysts estimates and revenue isn't reported yet. The specific earnings call date can be extracted from the QuoteSummary . Income Statement There are 2 ways to get the income statement of a symbol. Note: The current extracted statement is very limited/minimaliste, contributions are welcome to extract more data from the QuoteSummary . via Asset : import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset . income_statement . df ) ebit total_revenue gross_profit date 2018 - 12 - 31 - 2.530000e+08 2.146100e+10 4.042000e+09 2019 - 12 - 31 8.000000e+07 2.457800e+10 4.069000e+09 2020 - 12 - 31 1.951000e+09 3.153600e+10 6.630000e+09 2021 - 12 - 31 6.523000e+09 5.382300e+10 1.360600e+10 Note: asset.income_statement can be None for all assets that are not of type EQUITY . Directly via IncomeStatements import asyncio from pstock import IncomeStatements income_statement = asyncio . run ( IncomeStatements . get ( \"TSLA\" )) print ( income_statement . df ) ebit total_revenue gross_profit date 2018 - 12 - 31 - 2.530000e+08 2.146100e+10 4.042000e+09 2019 - 12 - 31 8.000000e+07 2.457800e+10 4.069000e+09 2020 - 12 - 31 1.951000e+09 3.153600e+10 6.630000e+09 2021 - 12 - 31 6.523000e+09 5.382300e+10 1.360600e+10 Note: You can also use QuarterlyIncomeStatements for (as the name says) quarterly income stamenets . News Gettings yahoo-finance news about a symbol also follows the same pattern. import asyncio from pstock import News news = asyncio . run ( News . get ( \"TSLA\" )) print ( news . df ) title url summary date 2022 - 02 - 15 12 : 11 : 46 + 00 : 00 Retail investor : 'I' m being careful just in ca ... https : // finance . yahoo . com / news / retail - investor ... Some retail investors are being more cautious ... 2022 - 02 - 15 12 : 23 : 00 + 00 : 00 Tesla \u2019 s Elon Musk Gave Away $ 5.7 Billion . But ... https : // finance . yahoo . com / m / d342cd56 - d5bb - 3957. .. Tesla CEO Elon Musk gave away more than 5 mill ... 2022 - 02 - 15 13 : 07 : 02 + 00 : 00 Company News for Feb 15 , 2022 https : // finance . yahoo . com / news / company - news - fe ... Companies In The News Are : IFS , OLK , THS , TSLA . .... 2022 - 02 - 15 19 : 23 : 43 + 00 : 00 Australia 's Syrah Resources to expand Louisian... https://finance.yahoo.com/news/australias-syra... Australian industrial materials firm Syrah Res... 2022 - 02 - 15 20 : 31 : 30 + 00 : 00 Biggest Companies in the World by Market Cap https : // finance . yahoo . com / m / 8 aead0a5 - ef35 - 3 d90 ... The world 's biggest companies by market cap op... Bars (Historical price data) A Bar in pstock is a pydantic model with the following fields: class Bar ( BaseModel ): date : datetime open : float high : float low : float close : float adj_close : float volume : float interval : timedelta Note: The interval is the time between bar open and close . To get Bars there are a couple of arguments that can be specified: interval : one of 1m , 2m , 5m , 15m , 30m , 1h , 1d , 5d , 1mo , 3mo , defaults to None period : one of 1d , 5d , 1mo , 3mo , 6mo , 1y , 2y , 5y , 10y , ytd , max , defaults to None start : Any date / datetime supported by pydnatic , defaults to None end : Any date / datetime supported by pydnatic , defaults to None events : one of div , split , div,splits , defaults to div,splits include_prepost : Bool, include Pre and Post market bars, default to False By default, if no argument is provided, the period is set to max and the interval to 3mo , example: Note : It is possible for yahoo-finance to return bars of different interval than what was specified in the request (example below, requested 3mo interval bars, got an interval of 1mo because TSLA is a relatively new stock and it's max period is around ~10 years by the time of writing). import asyncio from pstock import Bars bars = asyncio . run ( Bars . get ( \"TSLA\" )) print ( bars . df ) open high low close adj_close volume interval date 2010 - 07 - 01 5.000000 5.184000 2.996000 3.988000 3.988000 322879000.0 30 days 2010 - 08 - 01 4.100000 4.436000 3.478000 3.896000 3.896000 75191000.0 30 days 2010 - 09 - 01 3.924000 4.632000 3.900000 4.082000 4.082000 90229500.0 30 days 2010 - 10 - 01 4.138000 4.374000 4.000000 4.368000 4.368000 32739000.0 30 days 2010 - 11 - 01 4.388000 7.200000 4.210000 7.066000 7.066000 141575500.0 30 days ... ... ... ... ... ... ... ... 2021 - 11 - 01 1145.000000 1243.489990 978.599976 1144.760010 1144.760010 648671800.0 30 days 2021 - 12 - 01 1160.699951 1172.839966 886.119995 1056.780029 1056.780029 509945100.0 30 days 2022 - 01 - 01 1147.750000 1208.000000 792.010010 936.719971 936.719971 638471400.0 30 days 2022 - 02 - 01 935.210022 947.770020 850.700012 875.760010 875.760010 223112600.0 30 days 2022 - 02 - 15 900.000000 923.000000 893.377380 922.429993 922.429993 19085243.0 30 days [ 141 rows x 7 columns ] Note 1 : Yahoo-finance limits the interval of data we can fetch based on how old the data is. For example we can't get 1m bars for a period (or start/end) older than 7 days. Example of an interval error ... import asyncio from pstock import Bars bars = asyncio . run ( Bars . get ( \"TSLA\" , period = \"1mo\" , interval = \"1m\" )) print ( bars . df ) Traceback ( most recent call last ): File \"pstock/bar.py\" , line 243 , in < module > bars = asyncio . run ( Bars . get ( \"TSLA\" , period = \"1mo\" , interval = \"1m\" )) File \"user/.pyenv/versions/3.8.12/lib/python3.8/asyncio/runners.py\" , line 44 , in run return loop . run_until_complete ( main ) File \"user/.pyenv/versions/3.8.12/lib/python3.8/asyncio/base_events.py\" , line 616 , in run_until_complete return future . result () File \"pstock/bar.py\" , line 196 , in get return cls . load ( response = response ) File \"pstock/bar.py\" , line 169 , in load return cls . parse_obj ( get_ohlc_from_chart ( data )) File \"user/git/pstock/pstock/utils/chart.py\" , line 18 , in get_ohlc_from_chart raise ValueError ( f \"Yahoo-finance responded with an error: \\n { error } \" ) ValueError : Yahoo - finance responded with an error : { 'code' : 'Unprocessable Entity' , 'description' : '1m data not available for startTime=1642289894 and endTime=1644968294. Only 7 days worth of 1m granularity data are allowed to be fetched per request.' } > Note2 By leaving the interval parameter empty (= None ), pstock automatically tries to find the lowest interval possible based on how old the data requested is. import asyncio from pstock import Bars bars = asyncio . run ( Bars . get ( \"TSLA\" , period = \"1mo\" )) print ( bars . df ) # Automatically finds that the lowest interval for a period of `1mo` is `2m` open high low close adj_close volume interval date 2022 - 01 - 18 14 : 30 : 00 + 00 : 00 1028.000000 1030.000000 1023.000000 1023.983582 1023.983582 1125597.0 0 days 00 : 02 : 00 2022 - 01 - 18 14 : 32 : 00 + 00 : 00 1023.230103 1032.000000 1023.230103 1029.807983 1029.807983 228889.0 0 days 00 : 02 : 00 2022 - 01 - 18 14 : 34 : 00 + 00 : 00 1029.949951 1029.949951 1023.700012 1025.000000 1025.000000 248188.0 0 days 00 : 02 : 00 2022 - 01 - 18 14 : 36 : 00 + 00 : 00 1024.319946 1025.999878 1018.000000 1021.000000 1021.000000 289773.0 0 days 00 : 02 : 00 2022 - 01 - 18 14 : 38 : 00 + 00 : 00 1021.669922 1024.000000 1018.440002 1020.150024 1020.150024 183713.0 0 days 00 : 02 : 00 ... ... ... ... ... ... ... ... 2022 - 02 - 15 20 : 52 : 00 + 00 : 00 919.640015 920.989990 919.171570 919.179993 919.179993 189152.0 0 days 00 : 02 : 00 2022 - 02 - 15 20 : 54 : 00 + 00 : 00 919.320007 920.770020 918.869995 920.075012 920.075012 178398.0 0 days 00 : 02 : 00 2022 - 02 - 15 20 : 56 : 00 + 00 : 00 920.010010 921.000000 919.859985 920.940002 920.940002 207078.0 0 days 00 : 02 : 00 2022 - 02 - 15 20 : 58 : 00 + 00 : 00 920.900024 923.000000 920.750000 922.260010 922.260010 382232.0 0 days 00 : 02 : 00 2022 - 02 - 15 21 : 00 : 00 + 00 : 00 922.429993 922.429993 922.429993 922.429993 922.429993 0.0 0 days 00 : 02 : 00 [ 4093 rows x 7 columns ] Note3 Instead of using period it is also possible to set a specific start and optioally end value. If end is not set, it defaults to current UTC time. BarsMulti Sometimes we'll want to get bars for multiple symbols at the same time. import asyncio from pstock import BarsMulti bars = asyncio . run ( BarsMulti . get ([ \"TSLA\" , \"AAPL\" ], period = \"5d\" , interval = \"1d\" )) print ( bars . df ) TSLA AAPL open high low close adj_close volume interval open high low close adj_close volume interval date 2022 - 02 - 09 935.000000 946.270020 920.000000 932.000000 932.000000 17419800.0 1 days 176.050003 176.649994 174.899994 176.279999 176.279999 71285000.0 1 days 2022 - 02 - 10 908.369995 943.809998 896.700012 904.549988 904.549988 22042300.0 1 days 174.139999 175.479996 171.550003 172.119995 172.119995 90865900.0 1 days 2022 - 02 - 11 909.630005 915.960022 850.700012 860.000000 860.000000 26492700.0 1 days 172.330002 173.080002 168.039993 168.639999 168.639999 98566000.0 1 days 2022 - 02 - 14 861.570007 898.880005 853.150024 875.760010 875.760010 22515100.0 1 days 167.369995 169.580002 166.559998 168.880005 168.880005 86062800.0 1 days 2022 - 02 - 15 900.000000 923.000000 893.377380 922.429993 922.429993 19085243.0 1 days 170.970001 172.949997 170.250000 172.789993 172.789993 62512704.0 1 days Note Bars of a specific symbol can be accessed by using the sumbol as key: bars[\"TSLA\"].df == bars.df[\"TSLA\"] == Bars.get(\"TSLA\").df Sans-I/O protocol An I/O-free protocol implementation (colloquially referred to as a \u201csans-IO\u201d implementation) is an implementation of a network protocol that contains no code that does any form of network I/O or any form of asynchronous flow control. Put another way, a sans-IO protocol implementation is one that is defined entirely in terms of synchronous functions returning synchronous results, and that does not block or wait for any form of I/O. ............ By keeping async flow control and I/O out of your protocol implementation, it provides the ability to use that implementation across all forms of flow control. This means that the core of the protocol implementation is divorced entirely from the way I/O is done or the way the API is designed. -> https://sans-io.readthedocs.io Although pstock provides an async IO interface to get data from yahoo-finance, It is still extremly easy to use it with other http libraries or other ways to get data. A simple example is using the popular requests library: import requests from pstock import Asset , rdm_user_agent_value url = Asset . uri ( \"TSLA\" ) headers = { \"User-Agent\" : rdm_user_agent_value ()} response = requests . get ( url , headers = headers ) asset = Asset . load ( response = response ) The response object can be an str or bytes content of the response. Or it can even be the whole response object (should have a .read() method that returns content). The same can be done for generating Bars import requests from pstock import Bars , rdm_user_agent_value url = Bars . uri ( \"TSLA\" , interval = \"1m\" , period = \"1d\" ) headers = { \"User-Agent\" : rdm_user_agent_value ()} response = requests . get ( url , headers = headers ) bars = Bars . load ( response = response )","title":"User Guide"},{"location":"user-guide/#user-guide","text":"","title":"User Guide"},{"location":"user-guide/#assets","text":"An Asset in pstock terms is any ticker symbol supported by yahoo-finance. If the asset exists in yahoo-finance, you should be able to get it's quote summary using pstock . import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset ) # symbol='TSLA' name='Tesla, Inc.' asset_type='EQUITY' currency='USD' latest_price=920.0 sector='Consumer Cyclical' industry='Auto Manufacturers' An Asset will always have a: symbol : The ticker symbol of the asset name : The long/short name of the asset (depending on which is found, the long name takes priority) asset_type : Type of the asset, can be one of: EQUITY , CURRENCY , CRYPTOCURRENCY , ETF , FUTURE , INDEX currency : Currency of the asset, USD for US stocks latest_price : Latest price of the asset known by yahoo-finance, takes into account the pre-post market prices. Can be numpy.nan if no proce data is found. Note: if an asset_type exists in yahoo-finance but is not one of the above, feel free to open an issue or PR. In the meantime you can subclass the Asset object and override the type of asset_type and add the missing asset type The other fields are optional and can be filled depending on the asset_type , currently there are only fields for the EQUITY (stocks) asset_type: sector industry [trends](#trends) [earnings](#earnings) [income_statement](#income-statement) In addition to getting data about a single Asset , there is also the possibily to query multiple assets at the same time using Assets . The main benefit is that it provides the ability to directly convert the resulting list of assets into a pandas dataframe. import asyncio from pstock import Asset assets = asyncio . run ( Assets . get ([ \"TSLA\" , \"AAPL\" , \"GME\" ])) print ( assets . df ) name asset_type currency ... earnings trends income_statement symbol ... AAPL Apple Inc . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 0.99 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 13, ' buy ':... [{' date ': 2021-09-25, ' ebit ': 108949000000.0, ... GME GameStop Corp . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 1.35 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 2, ' buy ': ... [{' date ': 2021-01-30, ' ebit ': -249300000.0, ' t ... TSLA Tesla , Inc . EQUITY USD ... [{ 'quarter' : '1Q2021' , 'estimate' : 0.79 , 'actu... [{' date ': 2021-11-17, ' strong_buy ': 4, ' buy ': ... [{' date ': 2021-12-31, ' ebit ': 6523000000.0, ' t ... Note 1: Assets is also a pydantic model that will validate data that it pulls from yahoo-finance. Note 2: The generated pandas Dataframe is cached into a private ._df attribute and is computed only the first time it is accessed via the property .df . Note 3: Most if not all data objects in pstock have a .df property, and it's the recommended way to view and manipulate data when possible. Note 4: Assets , Bars , Earnings , News , ... can also be iterated over and support indexing and behave like a typing.List[Asset] , typing.List[Bar] , ...","title":"Assets"},{"location":"user-guide/#trends","text":"There are 2 ways to get the trends of a symbol. via Asset : import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset . trends . df ) strong_buy buy hold sell strong_sell score recomendation date 2021 - 11 - 17 4 4 8 6 0 2.73 HOLD 2021 - 12 - 17 11 6 13 6 0 2.39 BUY 2022 - 01 - 16 11 6 13 6 0 2.39 BUY 2022 - 02 - 15 4 4 8 6 0 2.73 HOLD Directly via Trends import asyncio from pstock import Trends trends = asyncio . run ( Trends . get ( \"TSLA\" )) print ( trends . df ) strong_buy buy hold sell strong_sell score recomendation date 2021 - 11 - 17 4 4 8 6 0 2.73 HOLD 2021 - 12 - 17 11 6 13 6 0 2.39 BUY 2022 - 01 - 16 11 6 13 6 0 2.39 BUY 2022 - 02 - 15 4 4 8 6 0 2.73 HOLD","title":"Trends"},{"location":"user-guide/#earnings","text":"There are 2 ways to get the earnings of a symbol. via Asset : import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset . earnings . df ) estimate actual status revenue earnings quarter 1 Q2021 0.79 0.93 Beat 1.038900e+10 4.380000e+08 2 Q2021 0.98 1.45 Beat 1.195800e+10 1.142000e+09 3 Q2021 1.59 1.86 Beat 1.375700e+10 1.618000e+09 4 Q2021 2.37 2.54 Beat 1.771900e+10 2.321000e+09 1 Q2022 2.25 NaN None NaN NaN Directly via Earnings import asyncio from pstock import Earnings earnings = asyncio . run ( Earnings . get ( \"TSLA\" )) print ( earnings . df ) estimate actual status revenue earnings quarter 1 Q2021 0.79 0.93 Beat 1.038900e+10 4.380000e+08 2 Q2021 0.98 1.45 Beat 1.195800e+10 1.142000e+09 3 Q2021 1.59 1.86 Beat 1.375700e+10 1.618000e+09 4 Q2021 2.37 2.54 Beat 1.771900e+10 2.321000e+09 1 Q2022 2.25 NaN None NaN NaN Note: The last earning have NaN / None values since we only have analysts estimates and revenue isn't reported yet. The specific earnings call date can be extracted from the QuoteSummary .","title":"Earnings"},{"location":"user-guide/#income-statement","text":"There are 2 ways to get the income statement of a symbol. Note: The current extracted statement is very limited/minimaliste, contributions are welcome to extract more data from the QuoteSummary . via Asset : import asyncio from pstock import Asset asset = asyncio . run ( Asset . get ( \"TSLA\" )) print ( asset . income_statement . df ) ebit total_revenue gross_profit date 2018 - 12 - 31 - 2.530000e+08 2.146100e+10 4.042000e+09 2019 - 12 - 31 8.000000e+07 2.457800e+10 4.069000e+09 2020 - 12 - 31 1.951000e+09 3.153600e+10 6.630000e+09 2021 - 12 - 31 6.523000e+09 5.382300e+10 1.360600e+10 Note: asset.income_statement can be None for all assets that are not of type EQUITY . Directly via IncomeStatements import asyncio from pstock import IncomeStatements income_statement = asyncio . run ( IncomeStatements . get ( \"TSLA\" )) print ( income_statement . df ) ebit total_revenue gross_profit date 2018 - 12 - 31 - 2.530000e+08 2.146100e+10 4.042000e+09 2019 - 12 - 31 8.000000e+07 2.457800e+10 4.069000e+09 2020 - 12 - 31 1.951000e+09 3.153600e+10 6.630000e+09 2021 - 12 - 31 6.523000e+09 5.382300e+10 1.360600e+10 Note: You can also use QuarterlyIncomeStatements for (as the name says) quarterly income stamenets .","title":"Income Statement"},{"location":"user-guide/#news","text":"Gettings yahoo-finance news about a symbol also follows the same pattern. import asyncio from pstock import News news = asyncio . run ( News . get ( \"TSLA\" )) print ( news . df ) title url summary date 2022 - 02 - 15 12 : 11 : 46 + 00 : 00 Retail investor : 'I' m being careful just in ca ... https : // finance . yahoo . com / news / retail - investor ... Some retail investors are being more cautious ... 2022 - 02 - 15 12 : 23 : 00 + 00 : 00 Tesla \u2019 s Elon Musk Gave Away $ 5.7 Billion . But ... https : // finance . yahoo . com / m / d342cd56 - d5bb - 3957. .. Tesla CEO Elon Musk gave away more than 5 mill ... 2022 - 02 - 15 13 : 07 : 02 + 00 : 00 Company News for Feb 15 , 2022 https : // finance . yahoo . com / news / company - news - fe ... Companies In The News Are : IFS , OLK , THS , TSLA . .... 2022 - 02 - 15 19 : 23 : 43 + 00 : 00 Australia 's Syrah Resources to expand Louisian... https://finance.yahoo.com/news/australias-syra... Australian industrial materials firm Syrah Res... 2022 - 02 - 15 20 : 31 : 30 + 00 : 00 Biggest Companies in the World by Market Cap https : // finance . yahoo . com / m / 8 aead0a5 - ef35 - 3 d90 ... The world 's biggest companies by market cap op...","title":"News"},{"location":"user-guide/#bars-historical-price-data","text":"A Bar in pstock is a pydantic model with the following fields: class Bar ( BaseModel ): date : datetime open : float high : float low : float close : float adj_close : float volume : float interval : timedelta Note: The interval is the time between bar open and close . To get Bars there are a couple of arguments that can be specified: interval : one of 1m , 2m , 5m , 15m , 30m , 1h , 1d , 5d , 1mo , 3mo , defaults to None period : one of 1d , 5d , 1mo , 3mo , 6mo , 1y , 2y , 5y , 10y , ytd , max , defaults to None start : Any date / datetime supported by pydnatic , defaults to None end : Any date / datetime supported by pydnatic , defaults to None events : one of div , split , div,splits , defaults to div,splits include_prepost : Bool, include Pre and Post market bars, default to False By default, if no argument is provided, the period is set to max and the interval to 3mo , example: Note : It is possible for yahoo-finance to return bars of different interval than what was specified in the request (example below, requested 3mo interval bars, got an interval of 1mo because TSLA is a relatively new stock and it's max period is around ~10 years by the time of writing). import asyncio from pstock import Bars bars = asyncio . run ( Bars . get ( \"TSLA\" )) print ( bars . df ) open high low close adj_close volume interval date 2010 - 07 - 01 5.000000 5.184000 2.996000 3.988000 3.988000 322879000.0 30 days 2010 - 08 - 01 4.100000 4.436000 3.478000 3.896000 3.896000 75191000.0 30 days 2010 - 09 - 01 3.924000 4.632000 3.900000 4.082000 4.082000 90229500.0 30 days 2010 - 10 - 01 4.138000 4.374000 4.000000 4.368000 4.368000 32739000.0 30 days 2010 - 11 - 01 4.388000 7.200000 4.210000 7.066000 7.066000 141575500.0 30 days ... ... ... ... ... ... ... ... 2021 - 11 - 01 1145.000000 1243.489990 978.599976 1144.760010 1144.760010 648671800.0 30 days 2021 - 12 - 01 1160.699951 1172.839966 886.119995 1056.780029 1056.780029 509945100.0 30 days 2022 - 01 - 01 1147.750000 1208.000000 792.010010 936.719971 936.719971 638471400.0 30 days 2022 - 02 - 01 935.210022 947.770020 850.700012 875.760010 875.760010 223112600.0 30 days 2022 - 02 - 15 900.000000 923.000000 893.377380 922.429993 922.429993 19085243.0 30 days [ 141 rows x 7 columns ] Note 1 : Yahoo-finance limits the interval of data we can fetch based on how old the data is. For example we can't get 1m bars for a period (or start/end) older than 7 days. Example of an interval error ... import asyncio from pstock import Bars bars = asyncio . run ( Bars . get ( \"TSLA\" , period = \"1mo\" , interval = \"1m\" )) print ( bars . df ) Traceback ( most recent call last ): File \"pstock/bar.py\" , line 243 , in < module > bars = asyncio . run ( Bars . get ( \"TSLA\" , period = \"1mo\" , interval = \"1m\" )) File \"user/.pyenv/versions/3.8.12/lib/python3.8/asyncio/runners.py\" , line 44 , in run return loop . run_until_complete ( main ) File \"user/.pyenv/versions/3.8.12/lib/python3.8/asyncio/base_events.py\" , line 616 , in run_until_complete return future . result () File \"pstock/bar.py\" , line 196 , in get return cls . load ( response = response ) File \"pstock/bar.py\" , line 169 , in load return cls . parse_obj ( get_ohlc_from_chart ( data )) File \"user/git/pstock/pstock/utils/chart.py\" , line 18 , in get_ohlc_from_chart raise ValueError ( f \"Yahoo-finance responded with an error: \\n { error } \" ) ValueError : Yahoo - finance responded with an error : { 'code' : 'Unprocessable Entity' , 'description' : '1m data not available for startTime=1642289894 and endTime=1644968294. Only 7 days worth of 1m granularity data are allowed to be fetched per request.' } > Note2 By leaving the interval parameter empty (= None ), pstock automatically tries to find the lowest interval possible based on how old the data requested is. import asyncio from pstock import Bars bars = asyncio . run ( Bars . get ( \"TSLA\" , period = \"1mo\" )) print ( bars . df ) # Automatically finds that the lowest interval for a period of `1mo` is `2m` open high low close adj_close volume interval date 2022 - 01 - 18 14 : 30 : 00 + 00 : 00 1028.000000 1030.000000 1023.000000 1023.983582 1023.983582 1125597.0 0 days 00 : 02 : 00 2022 - 01 - 18 14 : 32 : 00 + 00 : 00 1023.230103 1032.000000 1023.230103 1029.807983 1029.807983 228889.0 0 days 00 : 02 : 00 2022 - 01 - 18 14 : 34 : 00 + 00 : 00 1029.949951 1029.949951 1023.700012 1025.000000 1025.000000 248188.0 0 days 00 : 02 : 00 2022 - 01 - 18 14 : 36 : 00 + 00 : 00 1024.319946 1025.999878 1018.000000 1021.000000 1021.000000 289773.0 0 days 00 : 02 : 00 2022 - 01 - 18 14 : 38 : 00 + 00 : 00 1021.669922 1024.000000 1018.440002 1020.150024 1020.150024 183713.0 0 days 00 : 02 : 00 ... ... ... ... ... ... ... ... 2022 - 02 - 15 20 : 52 : 00 + 00 : 00 919.640015 920.989990 919.171570 919.179993 919.179993 189152.0 0 days 00 : 02 : 00 2022 - 02 - 15 20 : 54 : 00 + 00 : 00 919.320007 920.770020 918.869995 920.075012 920.075012 178398.0 0 days 00 : 02 : 00 2022 - 02 - 15 20 : 56 : 00 + 00 : 00 920.010010 921.000000 919.859985 920.940002 920.940002 207078.0 0 days 00 : 02 : 00 2022 - 02 - 15 20 : 58 : 00 + 00 : 00 920.900024 923.000000 920.750000 922.260010 922.260010 382232.0 0 days 00 : 02 : 00 2022 - 02 - 15 21 : 00 : 00 + 00 : 00 922.429993 922.429993 922.429993 922.429993 922.429993 0.0 0 days 00 : 02 : 00 [ 4093 rows x 7 columns ] Note3 Instead of using period it is also possible to set a specific start and optioally end value. If end is not set, it defaults to current UTC time.","title":"Bars (Historical price data)"},{"location":"user-guide/#barsmulti","text":"Sometimes we'll want to get bars for multiple symbols at the same time. import asyncio from pstock import BarsMulti bars = asyncio . run ( BarsMulti . get ([ \"TSLA\" , \"AAPL\" ], period = \"5d\" , interval = \"1d\" )) print ( bars . df ) TSLA AAPL open high low close adj_close volume interval open high low close adj_close volume interval date 2022 - 02 - 09 935.000000 946.270020 920.000000 932.000000 932.000000 17419800.0 1 days 176.050003 176.649994 174.899994 176.279999 176.279999 71285000.0 1 days 2022 - 02 - 10 908.369995 943.809998 896.700012 904.549988 904.549988 22042300.0 1 days 174.139999 175.479996 171.550003 172.119995 172.119995 90865900.0 1 days 2022 - 02 - 11 909.630005 915.960022 850.700012 860.000000 860.000000 26492700.0 1 days 172.330002 173.080002 168.039993 168.639999 168.639999 98566000.0 1 days 2022 - 02 - 14 861.570007 898.880005 853.150024 875.760010 875.760010 22515100.0 1 days 167.369995 169.580002 166.559998 168.880005 168.880005 86062800.0 1 days 2022 - 02 - 15 900.000000 923.000000 893.377380 922.429993 922.429993 19085243.0 1 days 170.970001 172.949997 170.250000 172.789993 172.789993 62512704.0 1 days Note Bars of a specific symbol can be accessed by using the sumbol as key: bars[\"TSLA\"].df == bars.df[\"TSLA\"] == Bars.get(\"TSLA\").df","title":"BarsMulti"},{"location":"user-guide/#sans-io-protocol","text":"An I/O-free protocol implementation (colloquially referred to as a \u201csans-IO\u201d implementation) is an implementation of a network protocol that contains no code that does any form of network I/O or any form of asynchronous flow control. Put another way, a sans-IO protocol implementation is one that is defined entirely in terms of synchronous functions returning synchronous results, and that does not block or wait for any form of I/O. ............ By keeping async flow control and I/O out of your protocol implementation, it provides the ability to use that implementation across all forms of flow control. This means that the core of the protocol implementation is divorced entirely from the way I/O is done or the way the API is designed. -> https://sans-io.readthedocs.io Although pstock provides an async IO interface to get data from yahoo-finance, It is still extremly easy to use it with other http libraries or other ways to get data. A simple example is using the popular requests library: import requests from pstock import Asset , rdm_user_agent_value url = Asset . uri ( \"TSLA\" ) headers = { \"User-Agent\" : rdm_user_agent_value ()} response = requests . get ( url , headers = headers ) asset = Asset . load ( response = response ) The response object can be an str or bytes content of the response. Or it can even be the whole response object (should have a .read() method that returns content). The same can be done for generating Bars import requests from pstock import Bars , rdm_user_agent_value url = Bars . uri ( \"TSLA\" , interval = \"1m\" , period = \"1d\" ) headers = { \"User-Agent\" : rdm_user_agent_value ()} response = requests . get ( url , headers = headers ) bars = Bars . load ( response = response )","title":"Sans-I/O protocol"}]}